<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>游戏破解网站合集</title>
      <link href="/2023/10/05/%E6%B8%B8%E6%88%8F%E7%A0%B4%E8%A7%A3%E7%BD%91%E7%AB%99%E5%90%88%E9%9B%86/"/>
      <url>/2023/10/05/%E6%B8%B8%E6%88%8F%E7%A0%B4%E8%A7%A3%E7%BD%91%E7%AB%99%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="最近突然想玩博得之门3"><a href="#最近突然想玩博得之门3" class="headerlink" title="最近突然想玩博得之门3"></a>最近突然想玩博得之门3</h2><div class="note info flat"><p>那我就发一发游戏破解网站合集</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/10/38e9184c36842f1e41014f5f93080a38.jpg"></p></div><h2 id="Switch520"><a href="#Switch520" class="headerlink" title="Switch520"></a>Switch520</h2><ul><li><p><a href="https://www.gamer520.com/">Switch520</a></p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/10/780c312d56a7afce1bd2bd8192f2a80a.jpg"></p></li></ul><h2 id="IGGGAMES"><a href="#IGGGAMES" class="headerlink" title="IGGGAMES"></a>IGGGAMES</h2><ul><li><p><a href="https://igg-games.com/">IGGGAMES</a></p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/10/bf783c88e69977fd2e81ba04d336b32b.jpg"></p></li></ul><h2 id="BYRUTOR"><a href="#BYRUTOR" class="headerlink" title="BYRUTOR"></a>BYRUTOR</h2><ul><li><a href="https://thebyrut.org/">BYRUTOR</a></li></ul><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/10/a1b5a2ef945ba6785bd467e27441b7e3.jpg"></p><h2 id="小妖怪分享-兴趣使然的资源搬运Blog"><a href="#小妖怪分享-兴趣使然的资源搬运Blog" class="headerlink" title="小妖怪分享|兴趣使然的资源搬运Blog"></a>小妖怪分享|兴趣使然的资源搬运Blog</h2><ul><li>游戏天堂：<a href="https://www.xyg688.com/">小妖怪分享|兴趣使然的资源搬运Blog (xyg688.com)</a></li><li>发布页：<a href="https://www.zzzz688.top/">小妖怪分享</a><br><img src="https://www.ahhhhfs.com/wp-content/uploads/2022/12/%E6%B8%B8%E6%88%8F%E5%A4%A9%E5%A0%82-%E5%85%A8%E7%90%83PC%E6%B8%B8%E6%88%8F%E7%A0%B4%E8%A7%A3%E4%B8%8B%E8%BD%BD%E7%AB%99-new-2048x1662.webp"></li></ul><h2 id="1111上游世界-需要挂梯子"><a href="#1111上游世界-需要挂梯子" class="headerlink" title="1111上游世界(需要挂梯子)"></a>1111上游世界(需要挂梯子)</h2><h2 id="上游世界-SWITCH游戏下载-PS4游戏下载-SWITCH中文游戏-vgter-net"><a href="#上游世界-SWITCH游戏下载-PS4游戏下载-SWITCH中文游戏-vgter-net" class="headerlink" title="* 上游世界 | SWITCH游戏下载 | PS4游戏下载 | SWITCH中文游戏 (vgter.net)"></a>* <a href="https://www.vgter.net/">上游世界 | SWITCH游戏下载 | PS4游戏下载 | SWITCH中文游戏 (vgter.net)</a></h2><p><img src="https://www.ahhhhfs.com/wp-content/uploads/2022/10/1667225486-94c8b5edba36432.webp"></p><h2 id="游戏星辰-switch游戏下载-NS破解游戏下载-ps4主机游戏下载综合社区-2023game-com"><a href="#游戏星辰-switch游戏下载-NS破解游戏下载-ps4主机游戏下载综合社区-2023game-com" class="headerlink" title="游戏星辰-switch游戏下载,NS破解游戏下载,ps4主机游戏下载综合社区 (2023game.com)"></a>游戏星辰-switch游戏下载,NS破解游戏下载,ps4主机游戏下载综合社区 (2023game.com)</h2><ul><li><a href="https://www.2023game.com/">游戏星辰-switch游戏下载,NS破解游戏下载,ps4主机游戏下载综合社区 (2023game.com)</a><br><img src="https://www.ahhhhfs.com/wp-content/uploads/2022/11/Switch-NSPS4-%E7%BB%BC%E5%90%88%E7%A0%B4%E8%A7%A3%E6%B8%B8%E6%88%8F%E4%B8%8B%E8%BD%BD%E7%AB%99-%E6%B8%B8%E6%88%8F%E5%B9%B4%E8%BD%AE.jpg"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 部署工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏破解 </tag>
            
            <tag> 破解网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(六)</title>
      <link href="/2023/05/15/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
      <url>/2023/05/15/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%85%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="创建注册表回调和进程回调"><a href="#创建注册表回调和进程回调" class="headerlink" title="创建注册表回调和进程回调"></a>创建注册表回调和进程回调</h1><h2 id="创建注册表回调"><a href="#创建注册表回调" class="headerlink" title="创建注册表回调"></a>创建注册表回调</h2><ol><li><p>了解CmRegisterCallback</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">CmRegisterCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           PEX_CALLBACK_FUNCTION Function,<span class="comment">//指向RegistryCallback例程的指针，这个参数就是用来监控注册表操作的回调函数</span></span></span><br><span class="line"><span class="params">  [in, optional] PVOID                 Context,<span class="comment">//配置管理器将作为CallbackContext参数传递给RegistryCallback例程中由驱动程序定义的值。此处设为NULL就好</span></span></span><br><span class="line"><span class="params">  [out]          PLARGE_INTEGER        Cookie <span class="comment">//指向LARGE＿INTEGER变量的指针，该变量接收标识回调例程的值。当注册回调例程的时候，次值将作为Cookie参数传递给CmUnRegisterCallback</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></li><li><p>注册注册表回调</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LARGE_INTEGER cookies = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//RegisterCallBack为自定义的函数</span></span><br><span class="line">CmRegisterCallback(RegisterCallBack, <span class="literal">NULL</span>, &amp;cookies);</span><br></pre></td></tr></table></figure></li><li><p>了解RegisterCallBack函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS </span><br><span class="line">  <span class="title function_">RegistryCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in PVOID  CallbackContext,<span class="comment">//在注册该RegistryCallback例程时，驱动程序作为Context参数传递给CmRegisterCallback的值</span></span></span><br><span class="line"><span class="params">    __in_opt PVOID  Argument1,<span class="comment">//REG＿NOTIFY＿CLASS联合体类型的值，用于标识正在执行的注册表的操作类型，以及是否在执行注册表操作之前或之后调用RegistryCallback例程</span></span></span><br><span class="line"><span class="params">    __in_opt PVOID  Argument2 <span class="comment">//指向特定于注册表操作信息的结构指针。结构的类型取决于Argument1中的REG＿NOTIFY＿CLASS类型值</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure></li><li><p>定义RegisterCallBack</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">RegisterCallBack</span><span class="params">(PVOID CallBackContext,PVOID arg1, PVOID arg2)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1是一个指向REG_NOTIFY_CLASS结构的指针，该结构包含了注册表操作的类型</span></span><br><span class="line">REG_NOTIFY_CLASS tempclass= (REG_NOTIFY_CLASS)arg1;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING tempname = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">RtlInitUnicodeString(&amp;tempname,<span class="string">L&quot;*JYXYYDS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (tempclass)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//注册表的创建及打开通知</span></span><br><span class="line"><span class="keyword">case</span> RegNtPreOpenKeyEx:</span><br><span class="line"><span class="keyword">case</span> RegNtPreOpenKey:</span><br><span class="line"><span class="keyword">case</span> RegNtPreCreateKey:</span><br><span class="line"><span class="keyword">case</span> RegNtPreCreateKeyEx:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//arg2是一个指向REG_CREATE_KEY_INFORMATION结构的指针，该结构包含了注册表操作的详细信息</span></span><br><span class="line">PREG_CREATE_KEY_INFORMATION tempinfo = (PREG_CREATE_KEY_INFORMATION)arg2;</span><br><span class="line"><span class="comment">//确保对象内存可访问</span></span><br><span class="line"><span class="comment">//if ((!MmIsAddressValid(RegistryObject)) ||</span></span><br><span class="line"><span class="comment">//(RegistryObject == NULL))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return STATUS_UNSUCCESSFUL;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">                <span class="comment">//这里使用__try是因为有时empinfo-&gt;CompleteName指针为0，FsRtlIsNameInExpression比较正则*JYXYYDS是否在CompleteName中</span></span><br><span class="line">__try&#123;</span><br><span class="line"><span class="keyword">if</span> (FsRtlIsNameInExpression(&amp;tempname,tempinfo-&gt;CompleteName,TRUE,<span class="literal">NULL</span>)) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:Bad Create\n&quot;</span>));</span><br><span class="line">status = STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">__except (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:PREG_CREATE_KEY_INFORMATION指针指向CompleteName为空，可能蓝屏\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//arg2是一个指向REG_POST_OPERATION_INFORMATION结构的指针，该结构包含了注册表操作的详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>卸载注册表回调</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卸载注册表回调</span></span><br><span class="line">CmUnRegisterCallback(cookies);</span><br></pre></td></tr></table></figure></li><li><p>效果<br><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-05-15-13-06-01_1fbcf3dd26f36ff929a8b375ee23fda2.png"></p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-05-15-13-09-10_407c9f219b76bda8bfed1ff33686e250.png"></p></li></ol><h2 id="创建进程回调"><a href="#创建进程回调" class="headerlink" title="创建进程回调"></a>创建进程回调</h2><ol><li><p>引入结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//注意结构体每个成员的大小</span></span><br><span class="line"><span class="comment">//且结构体需要内存对齐</span></span><br><span class="line">LIST_ENTRY listEntry;<span class="comment">//16</span></span><br><span class="line">ULONG64 __Undefined1;<span class="comment">//8</span></span><br><span class="line">ULONG64 __Undefined2;<span class="comment">//8</span></span><br><span class="line">ULONG64 __Undefined3;<span class="comment">//8</span></span><br><span class="line">ULONG64 NonPagedDebugInfo;<span class="comment">//8</span></span><br><span class="line">ULONG64 DllBase;<span class="comment">//8</span></span><br><span class="line">ULONG64 EntryPoint;<span class="comment">//8</span></span><br><span class="line">ULONG SizeOfImage;<span class="comment">//4</span></span><br><span class="line">UNICODE_STRING path;<span class="comment">//16</span></span><br><span class="line">UNICODE_STRING name;<span class="comment">//16</span></span><br><span class="line">ULONG   Flags;</span><br><span class="line">&#125;LDR_DATA, * PLDR_DATA;</span><br></pre></td></tr></table></figure></li><li><p>绕过签名校验</p><div class="note warning flat"><p>由于创建进程回调需要驱动有签名</p></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING szReg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//此绕过方法有概率蓝屏不建议使用，还是驱动签上名较好</span></span><br><span class="line">PLDR_DATA  ldr = (PLDR_DATA)driver-&gt;DriverSection;</span><br><span class="line">ldr-&gt;Flags|= <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性配置</p><p><code>点开驱动项目的属性</code>-&gt;<code>找到配置属性</code>-&gt;<code>链接器</code>-&gt;<code>命令行</code>-&gt;<code>加入/INTEGRITYCHECK </code></p><div class="note warning flat"><p>&#x2F;INTEGRITYCHECK是强制检查驱动签名，不管驱动有没有签名都建议加上这个</p></div></li><li><p>进程回调注册</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//g_ObRegistrationHandle定义全局变量，卸载需要用到</span></span><br><span class="line">       PVOID g_ObRegistrationHandle = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//attide对象高度用来决定先通知谁</span></span><br><span class="line">       UNICODE_STRING attide = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">OB_CALLBACK_REGISTRATION obReg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">OB_OPERATION_REGISTRATION oor = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">//获取版本，OB_FLT_REGISTRATION_VERSION</span></span><br><span class="line">obReg.Version = ObGetFilterVersion();</span><br><span class="line">        <span class="comment">//只注册了一个回调</span></span><br><span class="line">obReg.OperationRegistrationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">obReg.RegistrationContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">oor.ObjectType = PsProcessType;</span><br><span class="line">        <span class="comment">//只将句柄创建以及句柄复制通知</span></span><br><span class="line">oor.Operations = OB_OPERATION_HANDLE_CREATE| OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line">        <span class="comment">//赋值高度</span></span><br><span class="line">RtlInitUnicodeString(&amp;attide, <span class="string">L&quot;3211&quot;</span>);</span><br><span class="line">obReg.OperationRegistration = &amp;oor;</span><br><span class="line">        <span class="comment">//进程前回调，MoniteProcess为自己定义的函数</span></span><br><span class="line">oor.PreOperation = MoniteProcess;</span><br><span class="line">        <span class="comment">//不需要进程后回调</span></span><br><span class="line">oor.PostOperation = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//创建进程回调</span></span><br><span class="line">NTSTATUS status= ObRegisterCallbacks(&amp;obReg, &amp;g_ObRegistrationHandle);</span><br></pre></td></tr></table></figure></li><li><p>定义触发函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明PsGetProcessImageFileName,通过PEPROCESS获取文件名，不过只有8个字节</span></span><br><span class="line">NTKERNELAPI UCHAR* <span class="title function_">PsGetProcessImageFileName</span><span class="params">(__in PEPROCESS Process)</span>;</span><br><span class="line"><span class="comment">//返回值OB_PREOP_CALLBACK_STATUS为固定的，return OB_PREOP_SUCCESS</span></span><br><span class="line">OB_PREOP_CALLBACK_STATUS <span class="title function_">MoniteProcess</span><span class="params">(_In_ PVOID RegistrationContext,_Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation)</span>&#123;</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">PUCHAR ImageFileName=PsGetProcessImageFileName(OperationInformation-&gt;Object);</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:PUCHAR ImageFileName:%s\n&quot;</span>, ImageFileName));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(ImageFileName, <span class="string">&quot;monitor&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//将权限降为0，太粗暴了</span></span><br><span class="line">OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess = <span class="number">0</span>;</span><br><span class="line">OperationInformation-&gt;Parameters-&gt;DuplicateHandleInformation.DesiredAccess = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>卸载进程回调</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (g_ObRegistrationHandle)</span><br><span class="line">&#123;</span><br><span class="line">  ObUnRegisterCallbacks(g_ObRegistrationHandle);</span><br><span class="line">  KdPrint((<span class="string">&quot;jyx:删除进程回调\n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-05-15-00-09-36_0481a3a299c1cfd604e896c428e7e543.png"></p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-05-15-00-07-32_101a3d22848d7ca51a7b69a24519fbb5.png"></p></li></ol><div class="tabs" id="mycallback"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mycallback-1">注册表回调完整代码</button></li><li class="tab"><button type="button" data-href="#mycallback-2">进程回调完整代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mycallback-1"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;wdm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LARGE_INTEGER cookies = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">RegisterCallBack</span><span class="params">(PVOID CallBackContext,PVOID arg1, PVOID arg2)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1是一个指向REG_NOTIFY_CLASS结构的指针，该结构包含了注册表操作的类型</span></span><br><span class="line">REG_NOTIFY_CLASS tempclass= (REG_NOTIFY_CLASS)arg1;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING tempname = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">RtlInitUnicodeString(&amp;tempname,<span class="string">L&quot;*JYXYYDS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (tempclass)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> RegNtPreOpenKeyEx:</span><br><span class="line"><span class="keyword">case</span> RegNtPreOpenKey:</span><br><span class="line"><span class="keyword">case</span> RegNtPreCreateKey:</span><br><span class="line"><span class="keyword">case</span> RegNtPreCreateKeyEx:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//arg2是一个指向REG_CREATE_KEY_INFORMATION结构的指针，该结构包含了注册表操作的详细信息</span></span><br><span class="line">PREG_CREATE_KEY_INFORMATION tempinfo = (PREG_CREATE_KEY_INFORMATION)arg2;</span><br><span class="line"><span class="comment">//确保对象内存可访问</span></span><br><span class="line"><span class="comment">//if ((!MmIsAddressValid(RegistryObject)) ||</span></span><br><span class="line"><span class="comment">//(RegistryObject == NULL))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return STATUS_UNSUCCESSFUL;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">__try&#123;</span><br><span class="line"><span class="keyword">if</span> (FsRtlIsNameInExpression(&amp;tempname,tempinfo-&gt;CompleteName,TRUE,<span class="literal">NULL</span>)) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:Bad Create\n&quot;</span>));</span><br><span class="line">status = STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">__except (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:PREG_CREATE_KEY_INFORMATION指针指向CompleteName为空，可能蓝屏\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//arg2是一个指向REG_POST_OPERATION_INFORMATION结构的指针，该结构包含了注册表操作的详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnLoad</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入了 DriverUnLoad例程\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除进程回调</span></span><br><span class="line"><span class="comment">//if (cookies)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ObUnRegisterCallbacks(g_ObRegistrationHandle);</span></span><br><span class="line"><span class="comment">//KdPrint((&quot;jyx:删除进程回调\n&quot;));</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">CmUnRegisterCallback(cookies);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除注册表回调\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:退出 DriverUnLoad例程\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING szReg)</span></span><br><span class="line">&#123;</span><br><span class="line">driver-&gt;DriverUnload = DriverUnLoad;</span><br><span class="line"></span><br><span class="line">CmRegisterCallback(RegisterCallBack, <span class="literal">NULL</span>, &amp;cookies);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mycallback-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;wdm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//注意结构体每个成员的大小</span></span><br><span class="line"><span class="comment">//且结构体需要内存对齐</span></span><br><span class="line">LIST_ENTRY listEntry;<span class="comment">//16</span></span><br><span class="line">ULONG64 __Undefined1;<span class="comment">//8</span></span><br><span class="line">ULONG64 __Undefined2;<span class="comment">//8</span></span><br><span class="line">ULONG64 __Undefined3;<span class="comment">//8</span></span><br><span class="line">ULONG64 NonPagedDebugInfo;<span class="comment">//8</span></span><br><span class="line">ULONG64 DllBase;<span class="comment">//8</span></span><br><span class="line">ULONG64 EntryPoint;<span class="comment">//8</span></span><br><span class="line">ULONG SizeOfImage;<span class="comment">//4</span></span><br><span class="line">UNICODE_STRING path;<span class="comment">//16</span></span><br><span class="line">UNICODE_STRING name;<span class="comment">//16</span></span><br><span class="line">ULONG   Flags;</span><br><span class="line">&#125;LDR_DATA, * PLDR_DATA;</span><br><span class="line"></span><br><span class="line">PVOID g_ObRegistrationHandle = <span class="number">0</span>;</span><br><span class="line">NTKERNELAPI UCHAR* <span class="title function_">PsGetProcessImageFileName</span><span class="params">(__in PEPROCESS Process)</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">OB_PREOP_CALLBACK_STATUS <span class="title function_">MoniteProcess</span><span class="params">(_In_ PVOID RegistrationContext,_Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation)</span>&#123;</span><br><span class="line"></span><br><span class="line">PUCHAR ImageFileName=PsGetProcessImageFileName(OperationInformation-&gt;Object);</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:PUCHAR ImageFileName:%s\n&quot;</span>, ImageFileName));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(ImageFileName, <span class="string">&quot;monitor&quot;</span>)) &#123;</span><br><span class="line">OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess = <span class="number">0</span>;</span><br><span class="line">OperationInformation-&gt;Parameters-&gt;DuplicateHandleInformation.DesiredAccess = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnLoad</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入了 DriverUnLoad例程\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除进程回调</span></span><br><span class="line"><span class="keyword">if</span> (g_ObRegistrationHandle)</span><br><span class="line">&#123;</span><br><span class="line">ObUnRegisterCallbacks(g_ObRegistrationHandle);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除进程回调\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:退出 DriverUnLoad例程\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING szReg)</span></span><br><span class="line">&#123;</span><br><span class="line">driver-&gt;DriverUnload = DriverUnLoad;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING attide = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">OB_CALLBACK_REGISTRATION obReg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">OB_OPERATION_REGISTRATION oor = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">obReg.Version = ObGetFilterVersion();</span><br><span class="line"></span><br><span class="line">obReg.OperationRegistrationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">obReg.RegistrationContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">oor.ObjectType = PsProcessType;</span><br><span class="line"></span><br><span class="line">oor.Operations = OB_OPERATION_HANDLE_CREATE| OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line"></span><br><span class="line">RtlInitUnicodeString(&amp;attide, <span class="string">L&quot;3211&quot;</span>);</span><br><span class="line"></span><br><span class="line">obReg.OperationRegistration = &amp;oor;</span><br><span class="line"></span><br><span class="line">oor.PreOperation = MoniteProcess;</span><br><span class="line"></span><br><span class="line">oor.PostOperation = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS status= ObRegisterCallbacks(&amp;obReg, &amp;g_ObRegistrationHandle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:注册进程回调失败\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:注册进程回调成功,g_ObRegistrationHandle值是%X\n&quot;</span>, g_ObRegistrationHandle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios好用的工具</title>
      <link href="/2023/05/11/ios%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/05/11/ios%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Shadowrocket"><a href="#Shadowrocket" class="headerlink" title="Shadowrocket"></a>Shadowrocket</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>别名小火箭，可以连接各种类型的节点，挂载vpn</p><div class="note info flat"><p>功能强大且支持多种代理协议，如SS、SSR、V2Ray、Xray、Trojan等代理协议</p></div><h3 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h3><div class="note warning flat"><p>由于Shadowrocket在国区appstore已经下架，在美区appstore的需要花费2.99$，如果有visa等国外银行卡可以改成美区appid直接买，本文提供的是免费的共享账号的方法</p></div><h4 id="首先得到已购买Shadowrocket的共享账号"><a href="#首先得到已购买Shadowrocket的共享账号" class="headerlink" title="首先得到已购买Shadowrocket的共享账号"></a>首先得到已购买Shadowrocket的共享账号</h4><ul><li><input disabled="" type="checkbox"> 通过以下链接得到共享账号</li></ul><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://api.zxios.cn/appid/">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://cdn.staticaly.com/gh/JiangYinXiang3/cover@main/img/6315ec9737ac4.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">小火箭账号获取</div>            <div class="tag-link-sitename">ios小火箭</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></div><h4 id="获取到账号后"><a href="#获取到账号后" class="headerlink" title="获取到账号后"></a>获取到账号后</h4><p><img src="https://www.zhuanwaifu.com/uploads/image/20230416/1681647325715780.jpg"></p><h4 id="登录好之后可以通过搜索Shadowrocket，或者点击已购项目"><a href="#登录好之后可以通过搜索Shadowrocket，或者点击已购项目" class="headerlink" title="登录好之后可以通过搜索Shadowrocket，或者点击已购项目"></a>登录好之后可以通过搜索Shadowrocket，或者点击已购项目</h4><h2 id="TestFlight"><a href="#TestFlight" class="headerlink" title="TestFlight"></a>TestFlight</h2><h3 id="下载方法-1"><a href="#下载方法-1" class="headerlink" title="下载方法"></a>下载方法</h3><div class="note info flat"><p>作用就不多赘述了</p></div><p>直接在appstore下载即可(随便什么区)</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/IMG_2645(20230511-003423)_3ec812e1fa22f61d9983d7ef7488d284.PNG"></p><h2 id="Fair"><a href="#Fair" class="headerlink" title="Fair+"></a>Fair+</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>也可以连接各种类型的节点，挂载vpn</p><div class="note warning flat"><p>不过它只在TestFlight下载后才有，并且无法连接SS，连接不全，优点是方便下载到，不需要换区</p></div><h3 id="下载方法-2"><a href="#下载方法-2" class="headerlink" title="下载方法"></a>下载方法</h3><p>点击：</p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://testflight.apple.com/join/sdBZzV82">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://cdn.staticaly.com/gh/JiangYinXiang3/cover@main/img/6315ec9737ac4.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">在TestFlight中获取Fair+</div>            <div class="tag-link-sitename">获取Fair+</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></div><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/IMG_2647(20230511-010016)_99dc8318eb777740b1dd6ae92ca1fa4e.PNG"></p><div class="note warning flat"><p>它好像限定了前1万人，不太确定现在软件还能不能下</p></div><p>如果其不让下载我们可以改为美区appid(<a href="https://iyuantiao.com/fenxiangfuli/jiaocheng/tiktok-3.html">2023年最新注册美区Apple ID账号方法|美区苹果ID注册教程|小火箭shadowrocke和抖音国际版tiktok下载 - 爱远眺 (iyuantiao.com)</a>在美区appstore搜索Fair VPN（免费）、UltrasurfVPN（免费）、oneclick（免费）</p><div class="note info flat"><p>如果绑定支付方式处没有无这个选项的话，就挂一个美国的vpn就有了，记得选美国无税州，不然你想要买应用会要交税，别问我怎么知道的</p></div><h2 id="ShadowShare"><a href="#ShadowShare" class="headerlink" title="ShadowShare"></a>ShadowShare</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>每6个小时更新一次免费节点包括如SS、SSR、V2Ray、Xray、Trojan等代理协议</p><h3 id="下载方法-3"><a href="#下载方法-3" class="headerlink" title="下载方法"></a>下载方法</h3><p>appstore直接搜索ShadowShare</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/IMG_2646(20230511-004620)_f8cbb51a90833665ca1f799ec3a0ce3f.PNG"></p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><div class="note info flat"><p>抓包使用</p></div><h3 id="下载方法-4"><a href="#下载方法-4" class="headerlink" title="下载方法"></a>下载方法</h3><p>appstore搜索Stream<br><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/IMG_2649(20230511-011644)_6c925acf755778be6855992987c4c279.PNG"></p><h2 id="Stay"><a href="#Stay" class="headerlink" title="Stay"></a>Stay</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>可以使油猴脚本及自己编写的脚本应用于Safari的app</p><div class="note info flat"><p>可以先在电脑上写好,再粘贴到上面</p></div><h3 id="下载方法-5"><a href="#下载方法-5" class="headerlink" title="下载方法"></a>下载方法</h3><p>appstore直接搜索Stay</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/IMG_2650(20230511-011711)_b024e329268b3a137b37de67562b505b.PNG"></p><div class="note success flat"><p>暂时到这,后面有好用的ios软件还会补充</p></div>]]></content>
      
      
      <categories>
          
          <category> 部署工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(五)</title>
      <link href="/2023/05/08/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
      <url>/2023/05/08/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/</url>
      
        <content type="html"><![CDATA[<h1 id="驱动的加载与卸载"><a href="#驱动的加载与卸载" class="headerlink" title="驱动的加载与卸载"></a>驱动的加载与卸载</h1><div class="tabs" id="loaddriverandunloaddriver"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#loaddriverandunloaddriver-1">驱动加载</button></li><li class="tab"><button type="button" data-href="#loaddriverandunloaddriver-2">驱动卸载</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="loaddriverandunloaddriver-1"><div class="note success flat"><p>加载驱动过程</p></div><ol><li>用OpenSCManager打开服务控制管理器</li><li>用CreateService创建对应服务</li><li>如果驱动服务已经创建过, 则用OpenService打开服务</li><li>用StartService加载启动驱动服务</li><li>清理工作，用CloseServiceHandle关闭释放句柄</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数一:lpszDriverName驱动程序在注册表中的名字,名字随便只要唯一就行</span></span><br><span class="line"><span class="comment">//参数二:lpszDriverPath驱动程序的名字,如MyDriver.sys</span></span><br><span class="line">BOOL <span class="title function_">LoadDriver</span><span class="params">(<span class="type">char</span>* lpszDriverName, <span class="type">char</span>* lpszDriverPath)</span></span><br><span class="line">&#123;</span><br><span class="line">BOOL Ret = FALSE;</span><br><span class="line"><span class="comment">//用于保存 .sys的全路径名</span></span><br><span class="line"><span class="type">char</span> szDriverImagePath[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//得到完整的驱动路径</span></span><br><span class="line">GetFullPathNameA(lpszDriverPath, <span class="number">256</span>, szDriverImagePath, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//打印驱动路径</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;jyx:驱动路径:%s\n&quot;</span>, szDriverImagePath);</span><br><span class="line"><span class="comment">//获取SCM管理器的句柄</span></span><br><span class="line">SC_HANDLE hServiceMgr = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line"><span class="keyword">if</span> (hServiceMgr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenSCManager failed:%d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">SC_HANDLE hServiceDDK = CreateServiceA(</span><br><span class="line">hServiceMgr, <span class="comment">//SCM管理器的句柄</span></span><br><span class="line">lpszDriverName, <span class="comment">//驱动程序在注册表中的名字  </span></span><br><span class="line">lpszDriverName, <span class="comment">// 注册表驱动程序的 DisplayName 值  </span></span><br><span class="line">SERVICE_ALL_ACCESS, <span class="comment">//对驱动服务的访问权限,SERVICE_START 或者 SERVICE_ALL_ACCESS</span></span><br><span class="line">SERVICE_KERNEL_DRIVER, <span class="comment">//驱动服务的类型,表示加载的服务是驱动程序  </span></span><br><span class="line">SERVICE_DEMAND_START, <span class="comment">//驱动服务的启动类型,注册表驱动程序的 Start 值 ,指定当进程调用StartService函数时由服务控制管理器启动的服务。</span></span><br><span class="line">SERVICE_ERROR_IGNORE, <span class="comment">//驱动服务的错误控制类型,注册表驱动程序的 ErrorControl 值  </span></span><br><span class="line">szDriverImagePath, <span class="comment">//驱动服务的二进制文件的路径,szDriverImagePath 注册表驱动程序的路径 如: C:\\222\1.sys</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//驱动服务的加载顺序组,一般为NULL</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//驱动服务的标签标识符,一般为NULL</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//驱动服务的依赖项,一般为NULL</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//驱动服务的账户名,一般为NULL</span></span><br><span class="line"><span class="literal">NULL</span> <span class="comment">//驱动服务的密码,一般为NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (hServiceDDK == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;CreateService failed:%d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="comment">//如果服务已经创建过,则打开服务</span></span><br><span class="line"><span class="keyword">if</span> (GetLastError() == ERROR_SERVICE_EXISTS)</span><br><span class="line">&#123;</span><br><span class="line">hServiceDDK = OpenServiceA(hServiceMgr, lpszDriverName, SERVICE_ALL_ACCESS);</span><br><span class="line"><span class="keyword">if</span> (hServiceDDK == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenService failed:%d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询驱动服务状态</span></span><br><span class="line">SERVICE_STATUS ss;</span><br><span class="line">Ret = QueryServiceStatus(hServiceDDK, &amp;ss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ss.dwCurrentState == SERVICE_RUNNING)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;驱动服务为运行状态\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ret=StartService(hServiceDDK, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;jyx:加载驱动服务 StartService()=%d  GetLastError=%d&quot;</span>, Ret, GetLastError());</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理工作，用CloseServiceHandle关闭释放句柄,两个句柄都要关闭hServiceDDK和hServiceMgr</span></span><br><span class="line"><span class="keyword">if</span> (hServiceDDK)</span><br><span class="line">&#123;</span><br><span class="line">CloseServiceHandle(hServiceDDK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hServiceMgr)</span><br><span class="line">&#123;</span><br><span class="line">CloseServiceHandle(hServiceMgr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/LoadDriver_f7285561f8de5a7c9b689e704b15dd64.jpg"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="loaddriverandunloaddriver-2"><div class="note success flat"><p>卸载驱动过程</p></div><ol><li>用OpenSCManager打开服务控制管理器</li><li>用OpenService打开对应服务</li><li>用ControlService发送控制码给驱动</li><li>用DeleteService删除驱动服务</li><li>清理工作，用CloseServiceHandle关闭释放句柄</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数一:lpszDriverName加载驱动所对应的注册表中的名字</span></span><br><span class="line">BOOL <span class="title function_">UnLoadDriver</span><span class="params">(<span class="type">const</span>  <span class="type">char</span>* lpszDriverName)</span> &#123;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"><span class="comment">//获取SCM管理器的句柄</span></span><br><span class="line">SC_HANDLE hServiceMgr = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line"><span class="keyword">if</span> (hServiceMgr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenSCManager failed:%d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开驱动服务</span></span><br><span class="line">SC_HANDLE hServiceDDK = OpenServiceA(hServiceMgr, lpszDriverName, SERVICE_ALL_ACCESS);</span><br><span class="line"><span class="keyword">if</span> (hServiceDDK == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenService failed:%d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line">SERVICE_STATUS ss;</span><br><span class="line"><span class="comment">//发送停止命令</span></span><br><span class="line">bRet = ControlService(hServiceDDK, SERVICE_CONTROL_STOP, &amp;ss);</span><br><span class="line"><span class="keyword">if</span> (!bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ControlService failed:%d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除驱动服务</span></span><br><span class="line">bRet = DeleteService(hServiceDDK);</span><br><span class="line"><span class="keyword">if</span> (!bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;DeleteService failed:%d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清理工作，用CloseServiceHandle关闭释放句柄</span></span><br><span class="line"><span class="keyword">if</span> (hServiceDDK)</span><br><span class="line">&#123;</span><br><span class="line">CloseServiceHandle(hServiceDDK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hServiceMgr)</span><br><span class="line">&#123;</span><br><span class="line">CloseServiceHandle(hServiceMgr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/UnLoadDriver_018cb5c7bbfcb7588377aab327dd4a6f.jpg"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>lpszDriverName提示：</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/lpszDriverNametips_14ddbc73c367cdc5a7eafeaa5cfbab9a.jpg"></p><p>黄色涂抹部即lpszDriverName，本文所应用的lpszDriverName为JYXYYDS</p><p>一般情况下我们将lpszDriverName写为驱动名，可根据实际需要自己定义</p></div>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(四)</title>
      <link href="/2023/05/06/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
      <url>/2023/05/06/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h1 id="R3与R0通信交换数据"><a href="#R3与R0通信交换数据" class="headerlink" title="R3与R0通信交换数据"></a>R3与R0通信交换数据</h1><div class="note info flat"><p>一般我们对于驱动通信<code>R0层</code>与<code>R3层</code>中，R3层调用<code>DeviceIoControl</code>，R0层再通过IRP例程中的<code>IRP_MJ_DEVICE_CONTROL</code>来通信，较少使用IRP例程中的<code>IRP_MJ_WRITE</code>和<code>IRP_MJ_READ</code>，这两个例程一般是写单片机使用较多，本文在最后会介绍此二例程</p></div><h2 id="定义控制码"><a href="#定义控制码" class="headerlink" title="定义控制码"></a>定义控制码</h2><p>通过定义控制码来向驱动层说明R3层<code>DeviceIoControl</code>的操作类型，比如只是读或只是写，再或者既读取又写入。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 读测试   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 写测试   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 读写测试 CTL_CODE(FILE_DEVICE_UNKNOWN,0x801, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br></pre></td></tr></table></figure><h2 id="进一步了解DeviceIoControl"><a href="#进一步了解DeviceIoControl" class="headerlink" title="进一步了解DeviceIoControl"></a>进一步了解DeviceIoControl</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">DeviceIoControl</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_        HANDLE       hDevice,<span class="comment">//CreateFile打开驱动设备 返回的句柄</span></span></span><br><span class="line"><span class="params">  _In_        DWORD        dwIoControlCode,<span class="comment">//控制码 CTL_CODE</span></span></span><br><span class="line"><span class="params">  _In_opt_    LPVOID       lpInBuffer,<span class="comment">//输入缓冲区指针</span></span></span><br><span class="line"><span class="params">  _In_        DWORD        nInBufferSize,<span class="comment">//输入缓冲区大小</span></span></span><br><span class="line"><span class="params">  _Out_opt_   LPVOID       lpOutBuffer,<span class="comment">//返回缓冲区</span></span></span><br><span class="line"><span class="params">  _In_        DWORD        nOutBufferSize,<span class="comment">//返回缓冲区大小</span></span></span><br><span class="line"><span class="params">  _Out_opt_   LPDWORD      lpBytesReturned,<span class="comment">//返回字节数</span></span></span><br><span class="line"><span class="params">  _Inout_opt_ LPOVERLAPPED lpOverlapped <span class="comment">//(可选)指向OVERLAPPED结构的指针,一般填NULL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>关于第一参数可以参考</li></ul><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://jiangyinxiang2.github.io/2023/04/27/x64驱动学习(三)">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://cdn.staticaly.com/gh/JiangYinXiang3/cover@main/img/6315ec9737ac4.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">CreateFile打开驱动设备</div>            <div class="tag-link-sitename">JYX</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></div><h2 id="R0层获取DeviceIoControl的lpInBuffer"><a href="#R0层获取DeviceIoControl的lpInBuffer" class="headerlink" title="R0层获取DeviceIoControl的lpInBuffer"></a>R0层获取DeviceIoControl的lpInBuffer</h2><p>R0层通过此片缓冲区<code>PIRP pirp-&gt;AssociatedIrp.SystemBuffer</code>来获取R3层传递的<code>lpInBuffer</code></p><h2 id="首先了解R3层向R0层传递即只写"><a href="#首先了解R3层向R0层传递即只写" class="headerlink" title="首先了解R3层向R0层传递即只写"></a>首先了解R3层向R0层传递即只写</h2><div class="note info flat"><p>只写的操作中，DeviceIoControl中的lpOutBuffer并不重要，只要定义了就行</p></div><ol><li><p>首先定义好lpInBuffer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本文定义的是一个结构体，实际中可以随自己的需要定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TINPUT_BUF</span> //结构自己定义，甚至也可以是一个字符串</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  DWORD m_arg1;</span><br><span class="line">  DWORD m_arg2;</span><br><span class="line">  DWORD m_arg3;</span><br><span class="line">  DWORD m_arg4;</span><br><span class="line">  DWORD m_arg5;</span><br><span class="line">  DWORD m_arg6;</span><br><span class="line">  <span class="type">char</span>* mychar;</span><br><span class="line">&#125;TINPUT_BUF;</span><br><span class="line">TINPUT_BUF inBuf = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0x6ABC666</span>,<span class="string">&quot;aaaa&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>再定义好lpOutBuffer和lpBytesReturned</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD dwRetSize = <span class="number">0</span>;</span><br><span class="line">DWORD OutBuf[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//输出缓冲区，缓冲区的类型也可以自己定义 对于写来说OutBuf不重要</span></span><br></pre></td></tr></table></figure></li><li><p>R3层调用DeviceIoControl</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DeviceIoControl(DeviceHandle, 写测试, &amp;inBuf, <span class="keyword">sizeof</span>(inBuf), &amp;OutBuf, <span class="keyword">sizeof</span>(OutBuf), &amp;dwRetSize, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>R3层的代码完成</p></li><li><p>R0层取出控制码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PIO_STACK_LOCATION irpStackL = IoGetCurrentIrpStackLocation(pirp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line">UINT32 控制码 = irpStackL-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//取出控制码</span></span><br></pre></td></tr></table></figure></li><li><p>R0层进行比对控制码进入只写函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (控制码 == 写测试) &#123;</span><br><span class="line">  IRP_写测试(pirp);</span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只写函数中的内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> IRP_写测试(PIRP pirp) &#123;</span><br><span class="line">TINPUT_BUF* MySystemBuffer = (TINPUT_BUF*)pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:接受用户层传来的参数:%X,%X,%X,%X,%X,%X,%s&quot;</span>, MySystemBuffer-&gt;m_arg1, MySystemBuffer-&gt;m_arg2, MySystemBuffer-&gt;m_arg3, MySystemBuffer-&gt;m_arg4, MySystemBuffer-&gt;m_arg5, MySystemBuffer-&gt;m_arg6, MySystemBuffer-&gt;mychar));</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-05-06-16-05-56_410c1a07f55f9be111ae1cbbd4d0d7b5.png"></p></li><li><p>完整源码</p></li></ol><div class="tabs" id="mywritecode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mywritecode-1">R3层源码</button></li><li class="tab"><button type="button" data-href="#mywritecode-2">R0层源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mywritecode-1"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD dwRetSize = <span class="number">0</span>;<span class="comment">//返回字节数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TINPUT_BUF</span> //结构自己定义，甚至也可以是一个字符串</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD m_arg1;</span><br><span class="line">DWORD m_arg2;</span><br><span class="line">DWORD m_arg3;</span><br><span class="line">DWORD m_arg4;</span><br><span class="line">DWORD m_arg5;</span><br><span class="line">DWORD m_arg6;</span><br><span class="line"><span class="type">char</span>* mychar;</span><br><span class="line">&#125;TINPUT_BUF;</span><br><span class="line"><span class="comment">//结构</span></span><br><span class="line">TINPUT_BUF inBuf = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0x6ABC666</span>,<span class="string">&quot;aaaa&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//数组示例</span></span><br><span class="line">DWORD OutBuf[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//输出缓冲区，缓冲区的类型也可以自己定义 对于写测试来说OutBuf不重要</span></span><br><span class="line">DeviceIoControl(</span><br><span class="line">DeviceHandle,<span class="comment">//CreateFile打开驱动设备 返回的句柄</span></span><br><span class="line">写测试,<span class="comment">//控制码 CTL_CODE</span></span><br><span class="line">&amp;inBuf,<span class="comment">//输入缓冲区指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(inBuf),<span class="comment">//输入缓冲区大小</span></span><br><span class="line">&amp;OutBuf,<span class="comment">//返回缓冲区</span></span><br><span class="line"><span class="keyword">sizeof</span>(OutBuf),<span class="comment">//返回缓冲区大小</span></span><br><span class="line">&amp;dwRetSize, <span class="comment">//返回字节数</span></span><br><span class="line"><span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mywritecode-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 读测试   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 写测试   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 读写测试 CTL_CODE(FILE_DEVICE_UNKNOWN,0x801, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TINPUT_BUF</span> //结构自己定义，甚至也可以是一个字符串</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg3;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg4;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg5;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg6;</span><br><span class="line"><span class="type">char</span>* mychar;</span><br><span class="line">&#125;TINPUT_BUF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdriver-&gt;DeviceObject) &#123;</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">IoDeleteSymbolicLink(&amp;MySymbolicLinkName);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除符号链接=%wZ&quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">IoDeleteDevice(pdriver-&gt;DeviceObject);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除驱动设备&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动卸载成功\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;</span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateDevice(pdriver, <span class="keyword">sizeof</span>(pdriver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备创建成功\n&quot;</span>));</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateSymbolicLink(&amp;MySymbolicLinkName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;MySymbolicLinkName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (device) &#123;</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRP_写测试(PIRP pirp) &#123;</span><br><span class="line">TINPUT_BUF* MySystemBuffer = (TINPUT_BUF*)pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:接受用户层传来的参数:%X,%X,%X,%X,%X,%X,%s&quot;</span>, MySystemBuffer-&gt;m_arg1, MySystemBuffer-&gt;m_arg2, MySystemBuffer-&gt;m_arg3, MySystemBuffer-&gt;m_arg4, MySystemBuffer-&gt;m_arg5, MySystemBuffer-&gt;m_arg6, MySystemBuffer-&gt;mychar));</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IRP_Call</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是PDEVICE_OBJECT，不要写成了PDRIVER_OBJECT</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CreateFile\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_WRITE: &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户调用了\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CloseHandle\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了DeviceIoControl\n&quot;</span>));</span><br><span class="line">UINT32 控制码 = irpStackL-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line"><span class="keyword">if</span> (控制码 == 写测试) &#123;</span><br><span class="line">IRP_写测试(pirp);</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Pdriver, PUNICODE_STRING prestring)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:加载成功\n&quot;</span>));</span><br><span class="line">NTSTATUS status;</span><br><span class="line">Pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">status = CreateDevice(Pdriver);</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_WRITE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IRP_Call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="再了解R0层向R3层传递即只读"><a href="#再了解R0层向R3层传递即只读" class="headerlink" title="再了解R0层向R3层传递即只读"></a>再了解R0层向R3层传递即只读</h2><div class="note info flat"><p>只读的操作中，DeviceIoControl中的lpInBuffer并不重要，只要定义了就行</p></div><ol><li><p>首先定义好lpOutBuffer和lpBytesReturned并调用DeviceIoControl</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD dwRetSize = <span class="number">0</span>;<span class="comment">//返回字节数</span></span><br><span class="line"> DWORD inBuf;</span><br><span class="line"> <span class="comment">//数组示例</span></span><br><span class="line"> <span class="type">char</span> OutBuf[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//输出缓冲区，缓冲区的类型也可以自己定义 对于写测试来说OutBuf不重要</span></span><br><span class="line"> DeviceIoControl(</span><br><span class="line"> DeviceHandle,<span class="comment">//CreateFile打开驱动设备 返回的句柄</span></span><br><span class="line"> 读测试,<span class="comment">//控制码 CTL_CODE</span></span><br><span class="line"> &amp;inBuf,<span class="comment">//输入缓冲区指针</span></span><br><span class="line"> <span class="keyword">sizeof</span>(inBuf),<span class="comment">//输入缓冲区大小</span></span><br><span class="line"> &amp;OutBuf,<span class="comment">//返回缓冲区</span></span><br><span class="line"> <span class="keyword">sizeof</span>(OutBuf),<span class="comment">//返回缓冲区大小</span></span><br><span class="line"> &amp;dwRetSize, <span class="comment">//返回字节数</span></span><br><span class="line"> <span class="literal">NULL</span>);</span><br><span class="line"> OutputDebugStringA(OutBuf);<span class="comment">//此为MFC调试输出，方便查看</span></span><br></pre></td></tr></table></figure></li><li><p>R0层取出控制码并进行比对控制码进入只读函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (控制码==读测试) &#123;</span><br><span class="line">IRP_读测试(pirp);</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>R0层将内容写入缓冲区</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> IRP_读测试(PIRP pirp) &#123;</span><br><span class="line">PIO_STACK_LOCATION irpStackL = IoGetCurrentIrpStackLocation(pirp);</span><br><span class="line"><span class="type">char</span>* MySystemChar = pirp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//并非一定要使用char*，也可以是int*,甚至是UINT,只要能储存8个字节就行</span></span><br><span class="line"><span class="type">char</span> mychar[] = <span class="string">&quot;jyx:adnadiaduijaidjia&quot;</span>;<span class="comment">//本文为测试写的char[]，实际可根据需要自己定义</span></span><br><span class="line">memcpy_s(MySystemChar, <span class="number">512</span>, mychar,<span class="keyword">sizeof</span>(mychar));</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(mychar);<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p><code>pirp-&gt;IoStatus.Information = sizeof(mychar)</code>,此处IoStatus.Information需要根据所写入的内容的字节大小来修改，所以不是直接<code>pirp-&gt;IoStatus.Information=4</code></p></div></li><li><p>完整代码</p></li></ol><div class="tabs" id="myreadcode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#myreadcode-1">R3层完整代码</button></li><li class="tab"><button type="button" data-href="#myreadcode-2">R0层完整代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="myreadcode-1"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD dwRetSize = <span class="number">0</span>;<span class="comment">//返回字节数</span></span><br><span class="line">DWORD inBuf;</span><br><span class="line"><span class="comment">//数组示例</span></span><br><span class="line"><span class="type">char</span> OutBuf[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//输出缓冲区，缓冲区的类型也可以自己定义 对于写测试来说OutBuf不重要</span></span><br><span class="line">DeviceIoControl(</span><br><span class="line">DeviceHandle,<span class="comment">//CreateFile打开驱动设备 返回的句柄</span></span><br><span class="line">读测试,<span class="comment">//控制码 CTL_CODE</span></span><br><span class="line">&amp;inBuf,<span class="comment">//输入缓冲区指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(inBuf),<span class="comment">//输入缓冲区大小</span></span><br><span class="line">&amp;OutBuf,<span class="comment">//返回缓冲区</span></span><br><span class="line"><span class="keyword">sizeof</span>(OutBuf),<span class="comment">//返回缓冲区大小</span></span><br><span class="line">&amp;dwRetSize, <span class="comment">//返回字节数</span></span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line">OutputDebugStringA(OutBuf);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="myreadcode-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 读测试   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 写测试   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 读写测试 CTL_CODE(FILE_DEVICE_UNKNOWN,0x801, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TINPUT_BUF</span> //结构自己定义，甚至也可以是一个字符串</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg3;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg4;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg5;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg6;</span><br><span class="line"><span class="type">char</span>* mychar;</span><br><span class="line">&#125;TINPUT_BUF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdriver-&gt;DeviceObject) &#123;</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">IoDeleteSymbolicLink(&amp;MySymbolicLinkName);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除符号链接=%wZ&quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">IoDeleteDevice(pdriver-&gt;DeviceObject);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除驱动设备&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动卸载成功\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;</span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateDevice(pdriver, <span class="keyword">sizeof</span>(pdriver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备创建成功\n&quot;</span>));</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateSymbolicLink(&amp;MySymbolicLinkName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;MySymbolicLinkName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (device) &#123;</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRP_写测试(PIRP pirp) &#123;</span><br><span class="line">TINPUT_BUF* MySystemBuffer = (TINPUT_BUF*)pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:接受用户层传来的参数:%X,%X,%X,%X,%X,%X,%s&quot;</span>, MySystemBuffer-&gt;m_arg1, MySystemBuffer-&gt;m_arg2, MySystemBuffer-&gt;m_arg3, MySystemBuffer-&gt;m_arg4, MySystemBuffer-&gt;m_arg5, MySystemBuffer-&gt;m_arg6, MySystemBuffer-&gt;mychar));</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRP_读测试(PIRP pirp) &#123;</span><br><span class="line">PIO_STACK_LOCATION irpStackL = IoGetCurrentIrpStackLocation(pirp);</span><br><span class="line"><span class="type">char</span>* MySystemChar = pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line"><span class="type">char</span> mychar[] = <span class="string">&quot;jyx:adnadiaduijaidjia&quot;</span>;</span><br><span class="line">memcpy_s(MySystemChar, <span class="number">512</span>, mychar,<span class="keyword">sizeof</span>(mychar));</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(mychar);<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IRP_Call</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是PDEVICE_OBJECT，不要写成了PDRIVER_OBJECT</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CreateFile\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_WRITE: &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户调用了\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CloseHandle\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了DeviceIoControl\n&quot;</span>));</span><br><span class="line">UINT32 控制码 = irpStackL-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line"><span class="keyword">if</span> (控制码 == 写测试) &#123;</span><br><span class="line">IRP_写测试(pirp);</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (控制码==读测试) &#123;</span><br><span class="line">IRP_读测试(pirp);</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Pdriver, PUNICODE_STRING prestring)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:加载成功\n&quot;</span>));</span><br><span class="line">NTSTATUS status;</span><br><span class="line">Pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">status = CreateDevice(Pdriver);</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_WRITE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IRP_Call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="最后了解R0层与R3层传递即既读又写"><a href="#最后了解R0层与R3层传递即既读又写" class="headerlink" title="最后了解R0层与R3层传递即既读又写"></a>最后了解R0层与R3层传递即既读又写</h2><div class="tabs" id="myreadwritecode"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#myreadwritecode-1">R3层源码</button></li><li class="tab"><button type="button" data-href="#myreadwritecode-2">R0层源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="myreadwritecode-1"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD dwRetSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> InBuffer[] = &#123; <span class="number">56</span>,<span class="number">6</span>,<span class="number">15</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> OutBuffer=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">DeviceIoControl(DeviceHandle, 读写测试, &amp;InBuffer, <span class="keyword">sizeof</span>(InBuffer), &amp;OutBuffer, <span class="keyword">sizeof</span>(OutBuffer), &amp;dwRetSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Buffer[<span class="number">256</span>];</span><br><span class="line">sprintf_s(Buffer, <span class="string">&quot;jyx:%d+%d+%d=%d\n&quot;</span>, InBuffer[<span class="number">0</span>], InBuffer[<span class="number">1</span>], InBuffer[<span class="number">2</span>], OutBuffer);</span><br><span class="line"></span><br><span class="line">OutputDebugStringA(Buffer);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="myreadwritecode-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 读测试   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 写测试   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 读写测试 CTL_CODE(FILE_DEVICE_UNKNOWN,0x801, METHOD_BUFFERED,FILE_ANY_ACCESS) <span class="comment">//控制码测试</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TINPUT_BUF</span> //结构自己定义，甚至也可以是一个字符串</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg3;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg4;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg5;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> m_arg6;</span><br><span class="line"><span class="type">char</span>* mychar;</span><br><span class="line">&#125;TINPUT_BUF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdriver-&gt;DeviceObject) &#123;</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">IoDeleteSymbolicLink(&amp;MySymbolicLinkName);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除符号链接=%wZ&quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">IoDeleteDevice(pdriver-&gt;DeviceObject);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除驱动设备&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动卸载成功\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;</span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateDevice(pdriver, <span class="keyword">sizeof</span>(pdriver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备创建成功\n&quot;</span>));</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateSymbolicLink(&amp;MySymbolicLinkName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;MySymbolicLinkName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (device) &#123;</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRP_写测试(PIRP pirp) &#123;</span><br><span class="line">TINPUT_BUF* MySystemBuffer = (TINPUT_BUF*)pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:接受用户层传来的参数:%X,%X,%X,%X,%X,%X,%s&quot;</span>, MySystemBuffer-&gt;m_arg1, MySystemBuffer-&gt;m_arg2, MySystemBuffer-&gt;m_arg3, MySystemBuffer-&gt;m_arg4, MySystemBuffer-&gt;m_arg5, MySystemBuffer-&gt;m_arg6, MySystemBuffer-&gt;mychar));</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRP_读测试(PIRP pirp) &#123;</span><br><span class="line">PIO_STACK_LOCATION irpStackL = IoGetCurrentIrpStackLocation(pirp);</span><br><span class="line"><span class="type">char</span>* MySystemChar = pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line"><span class="type">char</span> mychar[] = <span class="string">&quot;jyx:adnadiaduijaidjia&quot;</span>;</span><br><span class="line">memcpy_s(MySystemChar, <span class="number">512</span>, mychar,<span class="keyword">sizeof</span>(mychar));</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(mychar);<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRP_读写测试(PIRP pirp) &#123;</span><br><span class="line"></span><br><span class="line">PIO_STACK_LOCATION irpStackL = IoGetCurrentIrpStackLocation(pirp);</span><br><span class="line"><span class="type">int</span>* GetInComing = (<span class="type">int</span>*)pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:%d+%d+%d=%d\n&quot;</span>, GetInComing[<span class="number">0</span>], GetInComing[<span class="number">1</span>], GetInComing[<span class="number">2</span>], GetInComing[<span class="number">0</span>] + GetInComing[<span class="number">1</span>] + GetInComing[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">*(<span class="type">int</span>*)GetInComing = GetInComing[<span class="number">0</span>] + GetInComing[<span class="number">1</span>] + GetInComing[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(<span class="type">int</span>);<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IRP_Call</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是PDEVICE_OBJECT，不要写成了PDRIVER_OBJECT</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CreateFile\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_WRITE: &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户调用了\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CloseHandle\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了DeviceIoControl\n&quot;</span>));</span><br><span class="line">UINT32 控制码 = irpStackL-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line"><span class="keyword">if</span> (控制码 == 写测试) &#123;</span><br><span class="line">IRP_写测试(pirp);</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (控制码==读测试) &#123;</span><br><span class="line">IRP_读测试(pirp);</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (控制码 == 读写测试) &#123;</span><br><span class="line">IRP_读写测试(pirp);</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Pdriver, PUNICODE_STRING prestring)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:加载成功\n&quot;</span>));</span><br><span class="line">NTSTATUS status;</span><br><span class="line">Pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">status = CreateDevice(Pdriver);</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_WRITE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IRP_Call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="拓展例程IRP-MJ-WRITE和IRP-MJ-READ"><a href="#拓展例程IRP-MJ-WRITE和IRP-MJ-READ" class="headerlink" title="拓展例程IRP_MJ_WRITE和IRP_MJ_READ"></a>拓展例程IRP_MJ_WRITE和IRP_MJ_READ</h2><p>参考博主：</p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://blog.csdn.net/sh3llc0der/article/details/15760573">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://cdn.staticaly.com/gh/JiangYinXiang3/cover@main/img/6315ec9737ac4.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">详细介绍例程IRP_MJ_WRITE和IRP_MJ_READ</div>            <div class="tag-link-sitename">sh3llc0der</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></div><div class="tabs" id="irp_mj_writeandirp_mj_read"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#irp_mj_writeandirp_mj_read-1">IRP_MJ_WRITE</button></li><li class="tab"><button type="button" data-href="#irp_mj_writeandirp_mj_read-2">IRP_MJ_READ</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="irp_mj_writeandirp_mj_read-1"><ol><li><p>了解WriteFile函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">WriteFile</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in          HANDLE hFile,                   <span class="comment">// 文件句柄</span></span></span><br><span class="line"><span class="params">  __in          LPCVOID lpBuffer,               <span class="comment">// 要写入的数据</span></span></span><br><span class="line"><span class="params">  __in          DWORD nNumberOfBytesToWrite,    <span class="comment">// 要写入的字节数</span></span></span><br><span class="line"><span class="params">  __out         LPDWORD lpNumberOfBytesWritten, <span class="comment">// 实际写入的字节数</span></span></span><br><span class="line"><span class="params">  __in          LPOVERLAPPED lpOverlapped       <span class="comment">// OVERLAPPED 结构，一般设定为 NULL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></li><li><p>R3层通过调用WriteFile向R0层传输数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WriteFile(DeviceHandle, MyContent, <span class="keyword">sizeof</span>(MyContent), &amp;RetSize, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>R0层获取缓冲区的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* Buffer = (<span class="type">char</span>*)pirp-&gt;UserBuffer;<span class="comment">//R0层通过pirp中UserBuffer，不限定于char*,根据需要自己定义</span></span><br></pre></td></tr></table></figure></li><li><p>R3层源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD RetSize = <span class="number">0</span>;</span><br><span class="line"> <span class="type">char</span> MyContent[] = <span class="string">&quot;jyx:用户数据IRP_MJ_WRITE传来&quot;</span>;</span><br><span class="line"> WriteFile(DeviceHandle, MyContent, <span class="keyword">sizeof</span>(MyContent), &amp;RetSize, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>R0层源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdriver-&gt;DeviceObject) &#123;</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">IoDeleteSymbolicLink(&amp;MySymbolicLinkName);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除符号链接=%wZ&quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">IoDeleteDevice(pdriver-&gt;DeviceObject);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除驱动设备&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动卸载成功\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;</span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateDevice(pdriver, <span class="keyword">sizeof</span>(pdriver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备创建成功\n&quot;</span>));</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateSymbolicLink(&amp;MySymbolicLinkName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;MySymbolicLinkName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (device) &#123;</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IRP_Call</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是PDEVICE_OBJECT，不要写成了PDRIVER_OBJECT</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CreateFile\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_WRITE: &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户调用了IRP_MJ_WRITE\n&quot;</span>));</span><br><span class="line"><span class="type">char</span>* Buffer = (<span class="type">char</span>*)pirp-&gt;UserBuffer;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层传递了%s&quot;</span>, Buffer));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_READ: &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户调用了IRP_MJ_READ\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CloseHandle\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了DeviceIoControl\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Pdriver, PUNICODE_STRING prestring)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:加载成功\n&quot;</span>));</span><br><span class="line">NTSTATUS status;</span><br><span class="line">Pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">status = CreateDevice(Pdriver);</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_READ] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_WRITE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IRP_Call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-05-07-02-09-03_32acd248f19809d79cf6a185880161f4.png"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="irp_mj_writeandirp_mj_read-2"><ol><li><p>了解ReadFile函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">ReadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">  __in          HANDLE hFile,                   <span class="comment">// 文件句柄</span></span></span><br><span class="line"><span class="params">  __out         LPVOID lpBuffer,                <span class="comment">// 接收数据用的 buffer</span></span></span><br><span class="line"><span class="params">  __in          DWORD nNumberOfBytesToRead,     <span class="comment">// 要读取的字节数</span></span></span><br><span class="line"><span class="params">  __out         LPDWORD lpNumberOfBytesRead,    <span class="comment">// 实际读取到的字节数</span></span></span><br><span class="line"><span class="params">  __in          LPOVERLAPPED lpOverlapped       <span class="comment">// OVERLAPPED 结构，一般设定为 NULL </span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></li><li><p>R3层通过调用ReadFile得到R0层传输数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL Ret=ReadFile(DeviceHandle, OutBuffer,<span class="keyword">sizeof</span>(OutBuffer),&amp;RetSize,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>R0层修改缓冲区的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* Buffer = (<span class="type">char</span>*)pirp-&gt;UserBuffer;</span><br><span class="line"><span class="type">char</span> MyContent[] = <span class="string">&quot;jyx:驱动数据IRP_MJ_READ传来\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(pirp-&gt;UserBuffer&amp;&amp;irpStackL-&gt;Parameters.Read.Length&gt;=<span class="keyword">sizeof</span>(MyContent))&#123;</span><br><span class="line">RtlCopyMemory(Buffer, MyContent, <span class="keyword">sizeof</span>(MyContent));</span><br><span class="line">&#125;</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(MyContent);<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br></pre></td></tr></table></figure><p><code>pirp-&gt;UserBuffer</code>&amp;&amp;<code>irpStackL-&gt;Parameters.Read.Length&gt;=sizeof(MyContent)</code>,其中pirp-&gt;UserBuffer是判断指针是否为0，而irpStackL-&gt;Parameters.Read.Length&gt;&#x3D;sizeof(MyContent)是判断MyContent的内容字节是否小于R3层定义的OutBuffer，即是否小于本文所定义的512个字节</p><p><code>pirp-&gt;IoStatus.Information = sizeof(MyContent);</code>,此处与前文所述一致</p></li><li><p>R3层源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD RetSize = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> OutBuffer[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//获取从R0层返回的数据</span></span><br><span class="line">BOOL Ret=ReadFile(DeviceHandle, OutBuffer,<span class="keyword">sizeof</span>(OutBuffer),&amp;RetSize,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (Ret) &#123;</span><br><span class="line">OutputDebugStringA(OutBuffer);<span class="comment">//方便调试查看</span></span><br></pre></td></tr></table></figure></li><li><p>R0层源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdriver-&gt;DeviceObject) &#123;</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">IoDeleteSymbolicLink(&amp;MySymbolicLinkName);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除符号链接=%wZ&quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">IoDeleteDevice(pdriver-&gt;DeviceObject);</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除驱动设备&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动卸载成功\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;</span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\Device\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateDevice(pdriver, <span class="keyword">sizeof</span>(pdriver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备创建成功\n&quot;</span>));</span><br><span class="line">UNICODE_STRING MySymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;MySymbolicLinkName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>);</span><br><span class="line">status = IoCreateSymbolicLink(&amp;MySymbolicLinkName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;MySymbolicLinkName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;MySymbolicLinkName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (device) &#123;</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IRP_Call</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是PDEVICE_OBJECT，不要写成了PDRIVER_OBJECT</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CreateFile\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_WRITE: &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户调用了IRP_MJ_WRITE\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_READ: &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户调用了IRP_MJ_READ\n&quot;</span>));</span><br><span class="line"><span class="type">char</span>* Buffer = (<span class="type">char</span>*)pirp-&gt;UserBuffer;</span><br><span class="line"><span class="type">char</span> MyContent[] = <span class="string">&quot;jyx:驱动数据IRP_MJ_READ传来\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(pirp-&gt;UserBuffer&amp;&amp;irpStackL-&gt;Parameters.Read.Length&gt;=<span class="keyword">sizeof</span>(MyContent))&#123;</span><br><span class="line">RtlCopyMemory(Buffer, MyContent, <span class="keyword">sizeof</span>(MyContent));</span><br><span class="line">&#125;</span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(MyContent);<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CloseHandle\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了DeviceIoControl\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Pdriver, PUNICODE_STRING prestring)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:加载成功\n&quot;</span>));</span><br><span class="line">NTSTATUS status;</span><br><span class="line">Pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">status = CreateDevice(Pdriver);</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_READ] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_WRITE] = IRP_Call;</span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IRP_Call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果<img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-05-07-02-10-20_(1)_eeb3b45cba553ea7715b9dea5f44ebc3.png"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征码定位</title>
      <link href="/2023/04/29/%E7%89%B9%E5%BE%81%E7%A0%81%E5%AE%9A%E4%BD%8D/"/>
      <url>/2023/04/29/%E7%89%B9%E5%BE%81%E7%A0%81%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="特征码定位的算法"><a href="#特征码定位的算法" class="headerlink" title="特征码定位的算法"></a>特征码定位的算法</h2><p>一般特征码定位包括的算法有几种包括：</p><ol><li>暴力搜索</li><li>Kmp算法</li><li>SunDay算法</li><li>BM算法</li><li>······</li></ol><h2 id="关于实现Kmp算法和SunDay算法以及暴力搜索的源码"><a href="#关于实现Kmp算法和SunDay算法以及暴力搜索的源码" class="headerlink" title="关于实现Kmp算法和SunDay算法以及暴力搜索的源码"></a>关于实现Kmp算法和SunDay算法以及暴力搜索的源码</h2><div class="note info flat"><p>暴力搜索</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">voilentSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pat,<span class="type">const</span> <span class="type">char</span>* txt)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(txt);</span><br><span class="line"><span class="type">int</span> m = <span class="built_in">strlen</span>(pat);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(txt[i + j] != pat[j])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == m)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>Kmp算法</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pat, <span class="type">const</span> <span class="type">char</span>* text,vector&lt;<span class="type">int</span>&gt; next)</span></span>&#123; </span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(text))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pat[j])</span><br><span class="line">        &#123;</span><br><span class="line">++i; </span><br><span class="line">++j; </span><br><span class="line"><span class="keyword">if</span> (j==<span class="built_in">strlen</span>(pat)) &#123;</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">j = next[j]; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>SunDay算法</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SunDaySearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* 字串, <span class="type">const</span> <span class="type">char</span>* 主串)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(字串);</span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">strlen</span>(主串);</span><br><span class="line">    <span class="type">int</span> next[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">next[i] = len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">next[字串[i]] = len - i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len2 - len)</span><br><span class="line">    &#123;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (主串[i + j] == 字串[j])</span><br><span class="line">        &#123;</span><br><span class="line">j++;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= len)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i += next[主串[i + len]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于算法实现特征码定位"><a href="#基于算法实现特征码定位" class="headerlink" title="基于算法实现特征码定位"></a>基于算法实现特征码定位</h2><ul><li>暴力搜索实现定位</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchMemory</span><span class="params">(HANDLE hProcess, WORD FeatureCode[], BYTE FeatureCodeSize, DWORD64 StartAddress, DWORD64 EndAddress, std::vector&lt;DWORD64&gt;&amp; ResultArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MEMORY_BASIC_INFORMATION MemoryInformation;</span><br><span class="line">FeatureCodeSize -= <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">VirtualQueryEx</span>(hProcess, (LPCVOID)StartAddress, &amp;MemoryInformation, <span class="built_in">sizeof</span>(MemoryInformation)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (MemoryInformation.Protect == PAGE_EXECUTE_READ || MemoryInformation.Protect == PAGE_EXECUTE_READWRITE || MemoryInformation.Protect== PAGE_READWRITE) &#123;</span><br><span class="line">BYTE* MemoryData = <span class="keyword">new</span> BYTE[MemoryInformation.RegionSize];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, MemoryInformation.BaseAddress, MemoryData, MemoryInformation.RegionSize, <span class="literal">nullptr</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">MemoryInformation.RegionSize-=FeatureCodeSize;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; MemoryInformation.RegionSize; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;=FeatureCodeSize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (MemoryData[v+i]!=FeatureCode[i] &amp;&amp; FeatureCode[i]&lt;=<span class="number">255</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i == FeatureCodeSize)</span><br><span class="line">&#123;</span><br><span class="line">ResultArray.<span class="built_in">push_back</span>((DWORD64)MemoryInformation.BaseAddress+v);</span><br><span class="line">i += FeatureCodeSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] MemoryData;</span><br><span class="line">&#125;</span><br><span class="line">StartAddress = (DWORD64)MemoryInformation.BaseAddress + MemoryInformation.RegionSize + FeatureCodeSize + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (StartAddress&gt;=EndAddress) &#123;</span><br><span class="line"><span class="keyword">return</span> ResultArray.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HANDLE handle=<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE,<span class="number">15968</span>);</span><br><span class="line">WORD FeatureCode[] = &#123;<span class="number">0xD8</span>,<span class="number">00</span>,<span class="number">0xB8</span>,<span class="number">0x256</span>&#125;;<span class="comment">//0x256 代表是特征码中的??</span></span><br><span class="line">std::vector&lt;DWORD64&gt;ResultArray;</span><br><span class="line"><span class="type">int</span> number=<span class="built_in">SearchMemory</span>(handle, FeatureCode,<span class="built_in">sizeof</span>(FeatureCode),<span class="number">0x41000</span>,<span class="number">0x7ffffffff</span>, ResultArray);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ResultArray.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>, ResultArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数量是%d&quot;</span>, number);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SunDay算法实现定位</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKMAXSIZE 409600<span class="comment">//每次读取内存的最大大小</span></span></span><br><span class="line">BYTE* MemoryData;<span class="comment">//每次将读取的内存读入这里</span></span><br><span class="line"><span class="type">short</span> Next[<span class="number">260</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//特征码转字节集</span></span><br><span class="line"><span class="function">WORD <span class="title">GetTzmArray</span><span class="params">(<span class="type">char</span>* Tzm, WORD* TzmArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">WORD TzmLength = <span class="built_in">strlen</span>(Tzm) / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(Tzm); )<span class="comment">//将十六进制特征码转为十进制</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> num[<span class="number">2</span>];</span><br><span class="line">num[<span class="number">0</span>] = Tzm[i++];</span><br><span class="line">num[<span class="number">1</span>] = Tzm[i++];</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (num[<span class="number">0</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; num[<span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">WORD a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; num[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = num[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; num[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = num[i] - <span class="number">87</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; num[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = num[i] - <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sum = a[<span class="number">0</span>] * <span class="number">16</span> + a[<span class="number">1</span>];</span><br><span class="line">TzmArray[len++] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TzmArray[len++] = <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TzmLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">short</span>* next, WORD* Tzm, WORD TzmLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//特征码（字节集）的每个字节的范围在0-255（0-FF）之间，256用来表示问号，到260是为了防止越界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">260</span>; i++)</span><br><span class="line">next[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TzmLength; i++)</span><br><span class="line">next[Tzm[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索一块内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchMemoryBlock</span><span class="params">(HANDLE hProcess, WORD* Tzm, WORD TzmLength, <span class="type">unsigned</span> __int64 StartAddress, <span class="type">unsigned</span> <span class="type">long</span> size, vector&lt;<span class="type">unsigned</span> __int64&gt;&amp; ResultArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)StartAddress, MemoryData, size, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j, k; i &lt; size;)</span><br><span class="line">&#123;</span><br><span class="line">j = i; k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; k &lt; TzmLength &amp;&amp; j &lt; size &amp;&amp; (Tzm[k] == MemoryData[j] || Tzm[k] == <span class="number">256</span>); k++, j++);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == TzmLength)</span><br><span class="line">&#123;</span><br><span class="line">ResultArray.<span class="built_in">push_back</span>(StartAddress + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((i + TzmLength) &gt;= size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = Next[MemoryData[i + TzmLength]];</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">-1</span>)</span><br><span class="line">i += (TzmLength - Next[<span class="number">256</span>]);<span class="comment">//如果特征码有问号，就从问号处开始匹配，如果没有就i+=-1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i += (TzmLength - num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索整个程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchMemory</span><span class="params">(HANDLE hProcess, <span class="type">char</span>* Tzm, <span class="type">unsigned</span> __int64 StartAddress, <span class="type">unsigned</span> __int64 EndAddress, <span class="type">int</span> InitSize, vector&lt;<span class="type">unsigned</span> __int64&gt;&amp; ResultArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> BlockSize;</span><br><span class="line">MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line"></span><br><span class="line">WORD TzmLength = <span class="built_in">strlen</span>(Tzm) / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">WORD* TzmArray = <span class="keyword">new</span> WORD[TzmLength];</span><br><span class="line"></span><br><span class="line"><span class="built_in">GetTzmArray</span>(Tzm, TzmArray);</span><br><span class="line"><span class="built_in">GetNext</span>(Next, TzmArray, TzmLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化结果数组</span></span><br><span class="line">ResultArray.<span class="built_in">clear</span>();</span><br><span class="line">ResultArray.<span class="built_in">reserve</span>(InitSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">VirtualQueryEx</span>(hProcess, (LPCVOID)StartAddress, &amp;mbi, <span class="built_in">sizeof</span>(mbi)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取可读可写和可读可写可执行的内存块</span></span><br><span class="line"><span class="keyword">if</span> (mbi.Protect == PAGE_READWRITE || mbi.Protect == PAGE_EXECUTE_READWRITE)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">BlockSize = mbi.RegionSize;</span><br><span class="line"><span class="comment">//搜索这块内存</span></span><br><span class="line"><span class="keyword">while</span> (BlockSize &gt;= BLOCKMAXSIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SearchMemoryBlock</span>(hProcess, TzmArray, TzmLength, StartAddress + (BLOCKMAXSIZE * i), BLOCKMAXSIZE, ResultArray);</span><br><span class="line">BlockSize -= BLOCKMAXSIZE; i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SearchMemoryBlock</span>(hProcess, TzmArray, TzmLength, StartAddress + (BLOCKMAXSIZE * i), BlockSize, ResultArray);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">StartAddress += mbi.RegionSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EndAddress != <span class="number">0</span> &amp;&amp; StartAddress &gt; EndAddress)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ResultArray.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(TzmArray);</span><br><span class="line"><span class="keyword">return</span> ResultArray.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetAddress</span><span class="params">(DWORD pid ,<span class="type">char</span>* Tzm, <span class="type">unsigned</span> __int64 StartAddress, <span class="type">unsigned</span> __int64 EndAddress, vector&lt;<span class="type">unsigned</span> __int64&gt;&amp;ResultArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化MemoryData大小</span></span><br><span class="line">MemoryData = <span class="keyword">new</span> BYTE[BLOCKMAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过进程ID获取进程句柄</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">false</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SearchMemory</span>(hProcess, Tzm, StartAddress, EndAddress, <span class="number">255</span>, ResultArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">unsigned</span> __int64&gt; ResultArray;</span><br><span class="line">DWORD pid = 填写进程PID;</span><br><span class="line"><span class="built_in">GetAddress</span>(pid, (<span class="type">char</span>*)<span class="string">&quot;76 80 FB A0 76 F0 0B 9E 76 C0 F2 9D 76 20 F0 9D 76 30&quot;</span>, <span class="number">0x410000</span>, <span class="number">0xFFFFFFFF</span>, ResultArray);</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">unsigned</span> __int64&gt;::iterator it = ResultArray.<span class="built_in">begin</span>(); it != ResultArray.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, *it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kmp算法在搜寻特征码时慢于前两者，就不贴源码了，BM与SunDay运行效率差不多</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征码定位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(三)</title>
      <link href="/2023/04/27/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
      <url>/2023/04/27/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h2 id="驱动设备与符号链接"><a href="#驱动设备与符号链接" class="headerlink" title="驱动设备与符号链接"></a>驱动设备与符号链接</h2><h3 id="设备名称与符号链接名称说明"><a href="#设备名称与符号链接名称说明" class="headerlink" title="设备名称与符号链接名称说明"></a>设备名称与符号链接名称说明</h3><p>windows下的设备是以”&#x2F;Device&#x2F;[设备名]”形式命名的。例如磁盘分区的c盘，d盘的设备名称就是”&#x2F;Device&#x2F;HarddiskVolume1”,”&#x2F;Device&#x2F;HarddiskVolume2”, 当然也可以不指定设备名称。如果IoCreateDevice中没有指定设备名称，那么I&#x2F;O管理器会自动分配一个数字作为设备的名称。例如”&#x2F;Device&#x2F;00000001”。&#x2F;Device&#x2F;[设备名]，不容易记忆，通常符号链接可以理解为设备的别名，更重要的是设备名，只能被内核模式下的其他驱动所识别，而别名可以被用户模式下的应用程序识别，例如c盘，就是名为”c:”的符号链接，其真正的设备对象是”&#x2F;Device&#x2F;HarddiskVolume1”，所以在写驱动时候，一般我们创建符号链接，即使驱动中没有用到，这也算是一个好的习惯吧。<br>驱动中符号链接名是这样写的<br>L”&#x2F;&#x2F;??&#x2F;&#x2F;HelloDDK” —&gt;&#x2F;??&#x2F;HelloDDK<br>L”&#x2F;&#x2F;DosDevices&#x2F;&#x2F;HelloDDK”—&gt;&#x2F;DosDevices&#x2F;HelloDDK<br>在应用程序中，符号链接名：<br>L”.&#x2F;&#x2F;HelloDDK”–&gt;&#x2F;&#x2F;.&#x2F;HelloDDK</p><p>winobj和DeviceTree可以用来查看这些信息。</p><p>DosDevices的符号链接名就是??, 所以”&#x2F;&#x2F;DosDevices&#x2F;&#x2F;XXXX”其实就是”&#x2F;&#x2F;??&#x2F;&#x2F;XXXX”</p><h3 id="创建设备与符号链接的步骤"><a href="#创建设备与符号链接的步骤" class="headerlink" title="创建设备与符号链接的步骤"></a>创建设备与符号链接的步骤</h3><ol><li>将<code>\\DEVICE\\MyDriver</code>驱动设备名称赋值给MyDriver</li><li>通过IoCreateDevice来创建设备对象</li><li>再将<code>\\??\\MyDriver</code>符号链接名称赋值给uzSymbolName</li><li>再通过IoCreateSymbolicLink来创建符号链接</li><li>R3层就只需要调用CreateFileW或CreateFile来获得句柄</li><li>删除的话需要先通过IoDeleteSymbolicLink删除符号链接再IoDeleteDevice删除设备</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;<span class="comment">//用于存放设备对象</span></span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\DEVICE\\MyDriver&quot;</span>);<span class="comment">//驱动设备名字</span></span><br><span class="line"></span><br><span class="line">status = IoCreateDevice(driver, <span class="keyword">sizeof</span>(driver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS)<span class="comment">//STATUS_SUCCESS)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建成功，OK \n&quot;</span>));</span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">UNICODE_STRING uzSymbolName; <span class="comment">//符号链接名字 </span></span><br><span class="line">RtlInitUnicodeString(&amp;uzSymbolName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>); <span class="comment">//CreateFile</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;uzSymbolName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;uzSymbolName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;uzSymbolName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-R0层"><a href="#完整代码-R0层" class="headerlink" title="完整代码-R0层"></a>完整代码-R0层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DeviceIrpCtl</span><span class="params">(PDEVICE_OBJECT device, PIRP pirp)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数&quot;</span>));</span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line">ULONG CtlCode;</span><br><span class="line">ULONG InputBuffLength;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp); <span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL: <span class="comment">//DeviceIoControl</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了 DeviceIoControl&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE: <span class="comment">//CreateFile</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了 CreateFile&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE: <span class="comment">//CloseHandle</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了 CloseHandle&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的 倒数第二个参数lpBytesReturned</span></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级 </span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DeviceIrpCtl_Close</span><span class="params">(PDEVICE_OBJECT device, PIRP pirp)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数 DeviceIrpCtl_Close&quot;</span>));</span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line">ULONG CtlCode;</span><br><span class="line">ULONG InputBuffLength;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp); <span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line">  KdPrint((<span class="string">&quot;yjx:用户层调用了 CloseHandle DeviceIrpCtl_Close&quot;</span>));</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的 倒数第二个参数lpBytesReturned</span></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级 </span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数 DeviceIrpCtl_Close&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建驱动设备对象</span></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;<span class="comment">//用于存放设备对象</span></span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\DEVICE\\MyDriver&quot;</span>);<span class="comment">//驱动设备名字</span></span><br><span class="line"></span><br><span class="line">status = IoCreateDevice(driver, <span class="keyword">sizeof</span>(driver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS)<span class="comment">//STATUS_SUCCESS)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建成功，OK \n&quot;</span>));</span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">UNICODE_STRING uzSymbolName; <span class="comment">//符号链接名字 </span></span><br><span class="line">RtlInitUnicodeString(&amp;uzSymbolName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>); <span class="comment">//CreateFile</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;uzSymbolName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;uzSymbolName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;uzSymbolName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnLoad</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入了 DriverUnLoad例程&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (pDriver-&gt;DeviceObject)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除符号链接</span></span><br><span class="line"> </span><br><span class="line">UNICODE_STRING uzSymbolName; <span class="comment">//符号链接名字 </span></span><br><span class="line">RtlInitUnicodeString(&amp;uzSymbolName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>); <span class="comment">//CreateFile</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除符号链接=%wZ&quot;</span>,&amp;uzSymbolName));</span><br><span class="line">IoDeleteSymbolicLink(&amp;uzSymbolName);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除驱动设备&quot;</span>));</span><br><span class="line">IoDeleteDevice(pDriver-&gt;DeviceObject);<span class="comment">//删除设备对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:退出 DriverUnLoad例程&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver,PUNICODE_STRING szReg)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:我的第一个驱动,注册路径=%wZ&quot;</span>, szReg));</span><br><span class="line">driver-&gt;DriverUnload = DriverUnLoad;</span><br><span class="line"><span class="comment">//为驱动对象创建一个设备</span></span><br><span class="line">NTSTATUS status = CreateDevice(driver);<span class="comment">//</span></span><br><span class="line"><span class="comment">//注册IRP处理 例程</span></span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_CREATE] = DeviceIrpCtl; <span class="comment">//CreateFile</span></span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_CLOSE] = DeviceIrpCtl_Close;<span class="comment">//卸载驱动 CloseHandle</span></span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIrpCtl;<span class="comment">//DeviceIoControl</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-R3层"><a href="#完整代码-R3层" class="headerlink" title="完整代码-R3层"></a>完整代码-R3层</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Window.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HANDLE DeviceHandle = <span class="built_in">CreateFileW</span>(</span><br><span class="line"><span class="string">L&quot;\\??\\MyDriver&quot;</span>,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DeviceHandle是%p&quot;</span>,DeviceHandle);</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="comment">//暂停一下方便看到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-04-27-00-31-52_6e8b0cf1d60a96f404c32d268a018e8b.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(二)</title>
      <link href="/2023/04/26/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
      <url>/2023/04/26/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="驱动框架完善-IRP例程注册"><a href="#驱动框架完善-IRP例程注册" class="headerlink" title="驱动框架完善-IRP例程注册"></a>驱动框架完善-IRP例程注册</h2><h3 id="IRP例程种类及用途"><a href="#IRP例程种类及用途" class="headerlink" title="IRP例程种类及用途"></a>IRP例程种类及用途</h3><p>IRP(I&#x2F;O Request Package) 是输入输出请求包的简称</p><p>IRP_MJ_CREATE   请求一个句柄  CreateFile<br>IRP_MJ_CLOSE    关闭句柄  CloseHandle<br>IRP_MJ_READ     从设备得到数据 ReadFile<br>IRP_MJ_WRITE    传送数据到设备 WriteFile<br>IRP_MJ_DEVICE_CONTROL 控制操作利用IOCTL宏  DeviceIoControl</p><h3 id="IRP例程注册方式"><a href="#IRP例程注册方式" class="headerlink" title="IRP例程注册方式"></a>IRP例程注册方式</h3><p>例如<code>Pdriver-&gt;MajorFunction[IRP_MJ_CREATE]=指定函数</code></p><p>指定函数中必须包含PDEVICE_OBJECT pdevice, PIRP pirp这两个参数</p><h3 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT Pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:卸载成功\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IRP_Call</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是PDEVICE_OBJECT，不要写成了PDRIVER_OBJECT</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CreateFile\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CloseHandle\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了DeviceIoControl\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Pdriver, PUNICODE_STRING prestring)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:加载成功\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">Pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = IRP_Call;</span><br><span class="line"></span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = IRP_Call;</span><br><span class="line"></span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IRP_Call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成IRP的例程注册，后期可以写单独的函数方便R0层与R3层通信</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(一)</title>
      <link href="/2023/04/24/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
      <url>/2023/04/24/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装VS2019"><a href="#安装VS2019" class="headerlink" title="安装VS2019"></a>安装VS2019</h2><blockquote><p>下载Visual Studio Installer, 安装时工作负载选择 使用C++的桌面开发 。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2021010419162676_7dff4df4aaefad23de4961d37c91281f.png"></p></blockquote><blockquote><p>由于WDK 默认启用了 Spectre 缓解，需要在单个组件中添加生成工具对应版本的 Spectre 缓解库 。(这里只下载了x64&#x2F;x86处理器架构)</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104194224503_d3796ca6116cd74095f18f3ecd8d9518.png"></p></blockquote><h2 id="安装WDK"><a href="#安装WDK" class="headerlink" title="安装WDK"></a>安装WDK</h2><p>下载的 WDK 需要与 VS 2019下载时的 Windows 10 SDK 版本对应</p><blockquote><p>我这里下载的WDK所要求的版本号为 Windows 10 SDK (10.0.19041.685)。<br>在 Windows设置-应用 中可以查看当前安装的SDK与WDK版本是否一致，不一致可以到官网下载对应的版本。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104211649239_dcc591f2a0bc05df16e39514c7483c88.png"></p><p>以上都可以直接在官网下载:<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk">参考链接</a></p></blockquote><blockquote><p>等待WDK下载安装完成，关闭时默认选择安装 WDK VS 扩展。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104201951315_5e723f775c27b80332405470d3a9de2e.png"></p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104202210555_94c25096f97b250e8897e99cddb04c9b.png"></p><p>如果WDK安装完成后没有安装WDK VS 扩展，可以在WDK安装目录 <strong>Windows Kits\10\Vsix</strong> 中找到 <strong>WDK.vsix</strong> 文件双击打开。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210105001920314_3104266225459460f7ae48a18c712cc3.png"></p></blockquote><blockquote><p>所有安装完成后，打开VS2019，创建新项目中会出现 Driver 这一项，下面就可以进行驱动程序开发了。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104203550420_58440d51d37b6547776e05b987a347ea.png"></p></blockquote><h1 id="一个简单的HelloWorld驱动程序"><a href="#一个简单的HelloWorld驱动程序" class="headerlink" title="一个简单的HelloWorld驱动程序"></a>一个简单的HelloWorld驱动程序</h1><blockquote><p>新建Empty WDM Driver项目</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104213043805_5b4fdad63521319b00e5ce8a94a17d26.png"></p></blockquote><blockquote><p>添加源文件 driver.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ntddk.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ntifs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:卸载成功\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pregister)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//内核打印需要KdPrint，并且需要两个括号</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:HelloWorld\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定卸载函数</span></span><br><span class="line">pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><em><strong><strong>编译前</strong></strong></em></p><p>a.移除项目自动生成的.inf文件<br>b.配置属性 - C&#x2F;C++ -常规<br>警告等级 设置为 等级3<br>将警告视为错误 设置为 否</p><p>c.配置属性 - 链接器 -常规<br>将链接器警告视为错误 设置为 否</p><p>d.配置属性 - Driver Signing - General<br>Sign Mode 设置为 Off。</p><p>e.配置属性 - Inf2Cat - Run Inf2Cat设置为否</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信多开</title>
      <link href="/2023/04/23/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80/"/>
      <url>/2023/04/23/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="修改微信源文件实现多开"><a href="#修改微信源文件实现多开" class="headerlink" title="修改微信源文件实现多开"></a>修改微信源文件实现多开</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>计算机程序为避免多开，一般选择Mutex(互斥锁)、Event(事件)、Semaphore(信号量)、窗口、文件</p><h2 id="对这些常用系统api下断"><a href="#对这些常用系统api下断" class="headerlink" title="对这些常用系统api下断"></a>对这些常用系统api下断</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%801_ea7dc8abd2f15e23a114443dc6d492be.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/微信多开1_ea7dc8abd2f15e23a114443dc6d492be.jpg"></p><p>在x32dbg中ctrl+g去到CreateMutexW中，在CreateMutexW的地址附近对于CreateSemaphoreExW、CreateSemaphorew、CreateMutexExA、CreateMutexA、CreateEventW都下断</p><h2 id="发现断在CreateEventW上"><a href="#发现断在CreateEventW上" class="headerlink" title="发现断在CreateEventW上"></a>发现断在CreateEventW上</h2><p>一直断在CreateEventW上，并且一直断于线程读写、防止线程多开。因此我们尝试放开CreateEventW的断点</p><h2 id="放开后中直接断在CreateMutexW上"><a href="#放开后中直接断在CreateMutexW上" class="headerlink" title="放开后中直接断在CreateMutexW上"></a>放开后中直接断在CreateMutexW上</h2><p>直接Crtl+F9返回，F8步过</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%802_0de25c93b05045db4af30f4fd5e8a2c5.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/微信多开2_0de25c93b05045db4af30f4fd5e8a2c5.jpg"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过CreateMutexW，将CreateMutexW的返回值赋值给esi，在判断esi的数值是否为0，相等跳转，不相等则调用GetLastError，返回值与B7比较，因此直接强制跳转就可以了</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%803_b6388245c8682053d793929a8e344333.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/微信多开3_b6388245c8682053d793929a8e344333.jpg"></p><h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%804_8fb25e682b166a2904692a37ce1b0937.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/微信多开4_8fb25e682b166a2904692a37ce1b0937.jpg"></p><h2 id="效果不演示了"><a href="#效果不演示了" class="headerlink" title="效果不演示了"></a>效果不演示了</h2><p>效果便是一台电脑同时登录多个微信</p><h1 id="不修改源文件，通过互斥名关闭互斥量"><a href="#不修改源文件，通过互斥名关闭互斥量" class="headerlink" title="不修改源文件，通过互斥名关闭互斥量"></a>不修改源文件，通过互斥名关闭互斥量</h1><h2 id="进一步了解CreateMutexW"><a href="#进一步了解CreateMutexW" class="headerlink" title="进一步了解CreateMutexW"></a>进一步了解CreateMutexW</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutexW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bInitialOwner,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCWSTR               lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>第一个参数</strong>是安全属性结构体， <code>lpMutexAttributes</code> 为 NULL，则 mutex 获取默认的安全描述符。 为NULL即可。<br><strong>第二个参数</strong>是否被继承，如果此值为 TRUE ，并且调用方创建了互斥体，则调用线程获取互斥体对象的初始所有权。 否则，调用线程不会获取互斥体的所有权。为FALSE即可。<br><strong>第三个参数</strong>是<code>互斥体名称</code>，这个参数很关键。<br><strong>返回值</strong> 如果函数成功，则返回值是新创建的互斥体对象的句柄。如果函数失败，则返回值为 NULL。</p><p>找到这个名称对应的互斥体，然后将句柄给它关闭，就能实现多开了。也无需去修改其源代码。</p><h2 id="逆向CreateMutexW的第三个参数"><a href="#逆向CreateMutexW的第三个参数" class="headerlink" title="逆向CreateMutexW的第三个参数"></a>逆向CreateMutexW的第三个参数</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-01%20000014_83476d30b465e6a67245b27e7066fbb6.jpg"></p><p>微信判断是否多开的互斥体名称是<strong>_WeChat_App_Instance_Identity_Mutex_Name</strong></p><h2 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义需要的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_SUCCESS 0x00UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_INFO_LENGTH_MISMATCH 0xC0000004</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemHandleInformation 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_DEBUG_PRIVILEGE 0x14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义需要用到的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_OBJECT_INFORMATION_CLASSEX</span> &#123;</span><br><span class="line">    ObjBasicInformation = <span class="number">0</span>,</span><br><span class="line">    ObjNameInformation,</span><br><span class="line">    ObjTypeInformation,</span><br><span class="line">&#125; OBJECT_INFORMATION_CLASSEX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_PROCESSINFOCLASSEX</span></span><br><span class="line">&#123;</span><br><span class="line">    ProcessHandleInformation = <span class="number">20</span>,</span><br><span class="line">&#125;PROCESSINFOCLASSEX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG ProcessId;</span><br><span class="line">    BYTE ObjectTypeNumber;</span><br><span class="line">    BYTE Flags;</span><br><span class="line">    USHORT Handle;</span><br><span class="line">    PVOID Object;</span><br><span class="line">    ACCESS_MASK GrantAccess;</span><br><span class="line">&#125;SYSTEM_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE_INFORMATION</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD HandleCount;</span><br><span class="line">    SYSTEM_HANDLE Handles[<span class="number">1</span>];</span><br><span class="line">&#125;SYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OBJECT_NAME_INFORMATION</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING ObjectName;</span><br><span class="line">&#125;OBJECT_NAME_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明未导出API</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* ZwQueryInformationProcessProc)</span><span class="params">(HANDLE, PROCESSINFOCLASSEX, LPVOID, DWORD, PDWORD)</span></span>;</span><br><span class="line">ZwQueryInformationProcessProc ZwQueryInformationProcess;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* ZwQuerySystemInformationProc)</span><span class="params">(DWORD, PVOID, DWORD, DWORD*)</span></span>;</span><br><span class="line">ZwQuerySystemInformationProc ZwQuerySystemInformation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* ZwQueryObjectProc)</span><span class="params">(HANDLE, OBJECT_INFORMATION_CLASSEX, PVOID, ULONG, PULONG)</span></span>;</span><br><span class="line">ZwQueryObjectProc ZwQueryObject;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* RtlAdjustPrivilegeProc)</span><span class="params">(DWORD, BOOL, BOOL, PDWORD)</span></span>;</span><br><span class="line">RtlAdjustPrivilegeProc RtlAdjustPrivilege;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* ZwSuspendProcessProc)</span><span class="params">(HANDLE)</span></span>;</span><br><span class="line">ZwSuspendProcessProc ZwSuspendProcess;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* ZwResumeProcessProc)</span><span class="params">(HANDLE)</span></span>;</span><br><span class="line">ZwResumeProcessProc ZwResumeProcess;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable: 6011) </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable: 6001) </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable: 6387) </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提升进程权限</span></span><br><span class="line"><span class="function">BOOL <span class="title">ElevatePrivileges</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    TOKEN_PRIVILEGES tkp;</span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tkp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tkp, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化未导出API</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetUnDocumentAPI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ZwSuspendProcess = (ZwSuspendProcessProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwSuspendProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZwQuerySystemInformation = (ZwQuerySystemInformationProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwQuerySystemInformation&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZwQueryObject = (ZwQueryObjectProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwQueryObject&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZwResumeProcess = (ZwResumeProcessProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwResumeProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZwQueryInformationProcess = (ZwQueryInformationProcessProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwQueryInformationProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ZwSuspendProcess == <span class="literal">NULL</span>) || \</span><br><span class="line">        (ZwQuerySystemInformation == <span class="literal">NULL</span>) || \</span><br><span class="line">        (ZwQueryObject == <span class="literal">NULL</span>) || \</span><br><span class="line">        (ZwResumeProcess == <span class="literal">NULL</span>) || \</span><br><span class="line">        (ZwQueryInformationProcess == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭指定Mutex s</span></span><br><span class="line"><span class="function">BOOL <span class="title">closeMutexHandle</span><span class="params">(UINT Proc_id, <span class="type">const</span> <span class="type">wchar_t</span>* Mutex_name)</span> </span>&#123;</span><br><span class="line">    HANDLE duplicateHnd, sourceHnd = <span class="number">0</span>;</span><br><span class="line">    DWORD procHndNum;</span><br><span class="line">    SYSTEM_HANDLE* currnetHnd;</span><br><span class="line">    DWORD buffLen = <span class="number">0x1000</span>;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    SYSTEM_HANDLE_INFORMATION* buff = (SYSTEM_HANDLE_INFORMATION*)<span class="built_in">malloc</span>(buffLen);</span><br><span class="line">    UINT count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">ElevatePrivileges</span>() == FALSE) || (<span class="built_in">GetUnDocumentAPI</span>() == FALSE))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="built_in">ZwQuerySystemInformation</span>(SystemHandleInformation, buff, buffLen, &amp;buffLen);</span><br><span class="line">        <span class="keyword">if</span> (status == STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(buff);</span><br><span class="line">            buff = (SYSTEM_HANDLE_INFORMATION*)<span class="built_in">malloc</span>(buffLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    OBJECT_NAME_INFORMATION* objNameInfo = (OBJECT_NAME_INFORMATION*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    OBJECT_NAME_INFORMATION* objTypeInfo = (OBJECT_NAME_INFORMATION*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; (<span class="type">int</span>)buff-&gt;HandleCount; idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        currnetHnd = &amp;(buff-&gt;Handles[idx]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currnetHnd-&gt;ProcessId == Proc_id)</span><br><span class="line">        &#123;</span><br><span class="line">            sourceHnd = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS | PROCESS_DUP_HANDLE | PROCESS_SUSPEND_RESUME, FALSE, Proc_id);</span><br><span class="line">            (ZwSuspendProcess)(sourceHnd);</span><br><span class="line">            (ZwQueryInformationProcess)(sourceHnd, ProcessHandleInformation, &amp;procHndNum, <span class="built_in">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//进程有效句柄从4开始,每次以4递增</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> hndNum = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; (<span class="type">int</span>)procHndNum; hndNum += <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断是否为有效句柄，返回TRUE，就是有效句柄</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">DuplicateHandle</span>(sourceHnd,</span><br><span class="line">                    (HANDLE)hndNum,</span><br><span class="line">                    <span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">                    &amp;duplicateHnd, <span class="number">0</span>, FALSE, DUPLICATE_SAME_ACCESS))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">memset</span>(objNameInfo, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">                    <span class="built_in">memset</span>(objTypeInfo, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">ZwQueryObject</span>((HANDLE)duplicateHnd, ObjNameInformation, objNameInfo, <span class="number">0x1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">ZwQueryObject</span>((HANDLE)duplicateHnd, ObjTypeInformation, objTypeInfo, <span class="number">0x1000</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//找到互斥体 比较名字</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">wcscmp</span>(objTypeInfo-&gt;ObjectName.Buffer, <span class="string">L&quot;Mutant&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//OutputDebugString();</span></span><br><span class="line">                        <span class="keyword">if</span> (objNameInfo-&gt;ObjectName.Length != <span class="number">0</span> &amp;&amp; <span class="built_in">wcsstr</span>(objNameInfo-&gt;ObjectName.Buffer, Mutex_name) != <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;%ws\n&quot;</span>, objNameInfo-&gt;ObjectName.Buffer);</span><br><span class="line"></span><br><span class="line">                            <span class="function">wstring <span class="title">str</span><span class="params">(objNameInfo-&gt;ObjectName.Buffer)</span></span>;</span><br><span class="line">                            <span class="type">int</span> pos = str.<span class="built_in">rfind</span>(<span class="string">L&quot;\\&quot;</span>);</span><br><span class="line">                            wstring subStr = str.<span class="built_in">substr</span>(pos + <span class="number">1</span>, <span class="number">40</span>);</span><br><span class="line">                            <span class="keyword">if</span> (subStr == <span class="string">L&quot;_WeChat_App_Instance_Identity_Mutex_Name&quot;</span>) &#123;</span><br><span class="line">                                <span class="built_in">CloseHandle</span>(duplicateHnd);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">DuplicateHandle</span>(sourceHnd,</span><br><span class="line">                                    (HANDLE)hndNum,</span><br><span class="line">                                    <span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">                                    &amp;duplicateHnd, <span class="number">0</span>, FALSE, DUPLICATE_CLOSE_SOURCE))</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="built_in">CloseHandle</span>(duplicateHnd);</span><br><span class="line">                                    (ZwResumeProcess)(sourceHnd);</span><br><span class="line">                                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        count++;</span><br><span class="line">                        <span class="keyword">if</span> (count == <span class="number">20</span>) &#123; <span class="keyword">return</span> FALSE; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">CloseHandle</span>(duplicateHnd);</span><br><span class="line">                    idx++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">findPidByName</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* name)</span> </span>&#123;</span><br><span class="line">    HANDLE hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line">    pe.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="type">bool</span> b = <span class="built_in">Process32First</span>(hSnap, &amp;pe);</span><br><span class="line">    string str;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="comment">//pe.szExeFile;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcscmp</span>(pe.szExeFile, name) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;应用名称%ws,进程id %d\n&quot;</span>, pe.szExeFile, pe.th32ProcessID);</span><br><span class="line">            pId.<span class="built_in">push_back</span>(pe.th32ProcessID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        b = <span class="built_in">Process32Next</span>(hSnap, &amp;pe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ElevatePrivileges</span>();  <span class="comment">//提升当前进程权限</span></span><br><span class="line">    <span class="built_in">GetUnDocumentAPI</span>();    <span class="comment">//初始化未导出API</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pid;</span><br><span class="line"></span><br><span class="line">    pid = <span class="built_in">findPidByName</span>(<span class="string">L&quot;WeChat.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid.<span class="built_in">size</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;微信未打开\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//为空直接跳出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pid[i]);<span class="comment">//\Sessions\2\BaseNamedObjects\SM0:18508:168:WilStaging_02</span></span><br><span class="line">        <span class="built_in">closeMutexHandle</span>(pid[i], <span class="string">L&quot;\\Sessions\\2\\BaseNamedObjects\\_WeChat_App_Instance_Identity_Mutex_Name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 逆向学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信多开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个稳定的图床</title>
      <link href="/2023/04/18/%E6%9C%AC%E6%96%87%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/04/18/%E6%9C%AC%E6%96%87%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>比jsdelivr更加稳定的图床方案（国内图床）</p><h1 id="Github图床和Vika图床"><a href="#Github图床和Vika图床" class="headerlink" title="Github图床和Vika图床"></a>Github图床和Vika图床</h1><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>picgo：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>选择最新版本，然后下载的安装包</p><blockquote><p>注意：下载最新版本即可，如果vika图床无法使用，就卸载降级</p></blockquote><h2 id="Github图床"><a href="#Github图床" class="headerlink" title="Github图床"></a>Github图床</h2><blockquote><p>自定义域名，使用cdn：<a href="https://cdn.staticaly.com/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D@main">https://cdn.staticaly.com/gh/用户名/仓库名@main</a></p></blockquote><h2 id="Vika图床"><a href="#Vika图床" class="headerlink" title="Vika图床"></a>Vika图床</h2><p>vika注册地址：<a href="https://vika.cn/?inviteCode=55733216">https://vika.cn/?inviteCode=55733216</a></p><p>填写我的邀请码可以获得1000V币，3000V币可以找客服扩容</p><blockquote><p>邀请码：55733216</p></blockquote><p>一个空间有1G的容量，每个人只能创一个，一般我也不是很想用这个</p><h3 id="安装vika插件"><a href="#安装vika插件" class="headerlink" title="安装vika插件"></a>安装vika插件</h3><p>直接在picgo安装即可</p><h3 id="配置api和维格表id"><a href="#配置api和维格表id" class="headerlink" title="配置api和维格表id"></a>配置api和维格表id</h3><p>先去账户中心–开发者配置 可以生成你的api token</p><h3 id="记得图片过大将图片进行压缩"><a href="#记得图片过大将图片进行压缩" class="headerlink" title="记得图片过大将图片进行压缩"></a>记得图片过大将图片进行压缩</h3><blockquote><p>直接搜索在线图片压缩如<a href="https://docsmall.com/image-compress">在线图片压缩 - docsmall 在线图片压缩工具,在线图片压缩软件</a></p></blockquote><blockquote><p>或者直接在PicGo中直接安装compress 1.4.0插件</p></blockquote><h1 id="npm图床"><a href="#npm图床" class="headerlink" title="npm图床"></a>npm图床</h1><div class="note info flat"><p>以下会以<code>[AssetsRepo]</code>、<code>package</code>指代这个静态资源仓库、npm包名</p></div><ol><li><p>首先需要注册一个 npm 的账号。<a href="https://www.npmjs.com/signup/">访问npm 注册页面</a><br><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/01.png"></p></li><li><p>完成邮箱验证，注册完成后进入账号管理界面:头像-&gt;Account，拉倒最上方，你会看到<code>You have not verified your email address</code>字样的提示，点击以后按提示步骤验证你的邮箱。</p><p><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/02.png"></p></li><li><p>找到我们之前创建的图床仓库，在本地合适的位置把它<code>clone</code>下来。找个空文件夹打开终端输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:[username]/[AssetsRepo].git</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/[username]/[AssetsRepo].git</span><br><span class="line"></span><br><span class="line">在 <span class="built_in">clone</span> 下来的[AssetsRepo]文件夹内打开终端，输入以下指令切换回原生源</span><br></pre></td></tr></table></figure></li><li><p>在 clone 下来的[AssetsRepo]文件夹内打开终端，输入以下指令切换回原生源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure></li><li><p>添加本地 npm 用户设置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅第一次使用需要添加用户，之后会提示你输入你的npm账号密码以及注册邮箱</span></span><br><span class="line">npm adduser</span><br><span class="line"><span class="comment"># 非第一次使用直接登录即可，之后会提示你输入你的npm账号密码以及注册邮箱</span></span><br><span class="line">npm login</span><br></pre></td></tr></table></figure></li><li><p>运行 npm 初始化指令，把整个图床仓库打包，按照指示进行配置，注意需要事先确认你的包名没有和别人已发布的包重复，可以在 npm 官网搜索相应包名，搜不到就说明还没被占用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/03.png"></p><p>最后会输出一段 package.json，请求确认，输入 yes 即可。</p></li><li><p>然后输入发布指令，我们就可以把包发布到 npm 上了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></li><li><p>如果出现一下情况</p><p><code>403 403 Forbidden - PUT https://registry.npmjs.org/music - You do not have permission to publish &quot;music&quot;. Are you logged in as the correct user?</code></p><p>提示没有权限，其实就是你的<code>module</code>名在<code>npm</code>上已经被占用啦，这时候你就去需要去<code>npm</code>搜索你的模块名称，如果搜索不到，就可以用，并且把<code>package.json</code>里的<code>name</code>修改过来，重新<code>npm publish</code>。</p></li><li><p>jsdelivr+npm 的图片引用和 jsdelivr+github 很相似，例如我在<code>[AssetsRepo]</code>仓库里存放的<code>/img/index.png</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jsDelivr+github链接</span></span><br><span class="line">https://cdn.jsdelivr.net/gh/[GithubUserName]/[AssetsRepo]/img/index.png</span><br><span class="line"><span class="comment"># jsDelivr+npm链接</span></span><br><span class="line">https://cdn.jsdelivr.net/npm/[NpmPackageName]/img/index.png</span><br></pre></td></tr></table></figure><div class="note success flat"><p>可以看到 Npm 只需要提供包名即可。这也是一开始要求包名不重复的原因之一</p></div><p>jsDelivr+Npm 依然有 100MB 的包大小限制，但是 NPM 有丰富的国内节点。可以挑选一个使用。个人推荐知乎的。没有大小限制，而且也很稳定。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">【jsd出品，网宿国内节点】</span><br><span class="line">https://npm.elemecdn.com/:package@:version/:file</span><br><span class="line">【知乎出品，网宿国内节点】</span><br><span class="line">https://npm.elemecdn.com/:package@:version/:file</span><br><span class="line">【百度出品，网宿国内节点】</span><br><span class="line">https://code.bdstatic.com/npm/:package@:version/:file</span><br><span class="line">【饿了么出品，网宿国内节点】</span><br><span class="line">https://shadow.elemecdn.com/npm/:package@:version/:file</span><br></pre></td></tr></table></figure><div class="note info flat"><p>本文音乐库用的是知乎，例子<code>https://npm.elemecdn.com/music6@1.0.0/本草纲目/本草纲目.mp3</code></p></div>`<p>当然你也可以利用unpkg自建。(UNPKG 是一个内容源自 npm 的全球快速 CDN。它部署在 cloudflare 上，在大陆地区访问到的是香港节点。所以速度也不错。)</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://unpkg.com/:package@:version/:file</span><br></pre></td></tr></table></figure></li><li><p>如果每次都要在本地进行<code>npm publish</code>的话，npm 的提交是整个包一起上传的，不存在增量更新，耗时不说，而且还往往需要架梯子才能正常上传。所以我们可以把它交给 github action 来完成。</p><p>在<a href="https://www.npmjs.com/">npm 官网</a>-&gt;头像-&gt;Access Tokens-&gt;Generate New Token,勾选 Automation 选项，<code>Token</code>只会显示这一次，之后如果忘记了就只能重新生成重新配置了。</p><p><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/05.png"></p><p>在 github 的[AssetsRepo]仓库设置项里添加一个名为<code>NPM_TOKEN</code>的<code>secrets</code>，把获取的 Npm 的 Access token 输入进去。</p><p><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/06.png"></p><p>在本地的<code>[AssetsRepo]</code>文件夹下新建<code>[AssetsRepo]/.github/workflows/autopublish.yml</code>,</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Node.js</span> <span class="string">Package</span></span><br><span class="line"><span class="comment"># 监测图床分支，2020年10月后github新建仓库默认分支改为main，记得更改</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">publish-npm:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;12.x&quot;</span></span><br><span class="line">          <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">publish</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>在本地的<code>[AssetsRepo]</code>文件夹下打开终端，运行以下指令，上传新增内容至 github，即可触发部署。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将更改提交</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;npm publish&quot;</span></span><br><span class="line"><span class="comment"># 更新package版本号</span></span><br><span class="line">npm version patch</span><br><span class="line"><span class="comment"># 推送至github触发action</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>此处的四行指令顺序严格。<br>    每次更新 npm 图床都需要先修改<code>[AssetsRepo]\package.json</code>里的<code>version</code>,也就是版本号。<br>    而<code>npm version patch</code>即为更新<code> package.json</code> 里的版本号的指令，效果是末尾版本号+1，例如<code>0.0.1=&gt;0.0.2、1.1.3=&gt;1.1.4</code>。免去了打开<code>package.json</code>再修改版本号的麻烦。（大版本更新还是需要手动改的）<br>    更新 npm 图床务必要记得更新<code>package.json</code>里的版本号！</p></div></li></ol>]]></content>
      
      
      <categories>
          
          <category> 部署工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ消息与微信消息防撤回</title>
      <link href="/2023/04/17/QQ%E6%B6%88%E6%81%AF%E9%98%B2%E6%92%A4%E5%9B%9E/"/>
      <url>/2023/04/17/QQ%E6%B6%88%E6%81%AF%E9%98%B2%E6%92%A4%E5%9B%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="QQ防撤回"><a href="#QQ防撤回" class="headerlink" title="QQ防撤回"></a>QQ防撤回</h1><h2 id="前提须知"><a href="#前提须知" class="headerlink" title="前提须知"></a>前提须知</h2><ul><li>首先撤回的函数在im.dll模块中,并且用户与用户之间以及群内的撤回函数不同</li></ul><h2 id="在im-dll模块中搜索revoke，在每一个revoke上下一个断点"><a href="#在im-dll模块中搜索revoke，在每一个revoke上下一个断点" class="headerlink" title="在im.dll模块中搜索revoke，在每一个revoke上下一个断点"></a>在im.dll模块中搜索revoke，在每一个revoke上下一个断点</h2><ul><li>通过下断点来看在消息撤回前断在哪些断点上</li></ul><h2 id="发现断在这些断点上"><a href="#发现断在这些断点上" class="headerlink" title="发现断在这些断点上"></a>发现断在这些断点上</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-16%20141606_54b2d4c59bd17779246bf7cf7507ebd9.jpg" alt="&#39;https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-16%20141606_54b2d4c59bd17779246bf7cf7507ebd9.jpg&#39;"></p><h2 id="直接在函数头部返回"><a href="#直接在函数头部返回" class="headerlink" title="直接在函数头部返回"></a>直接在函数头部返回</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2_0590660d1ac0fca17da8c7eb63b768fd.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2_0590660d1ac0fca17da8c7eb63b768fd.jpg"></p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/3_d0a10b8e94ab13fc731bbf68060bca7a.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/3_d0a10b8e94ab13fc731bbf68060bca7a.jpg"></p><ul><li>发现是个人用户撤回2和群用户撤回3上可以阻止消息撤回</li></ul><h2 id="效果就不演示了，自己尝试就可以了"><a href="#效果就不演示了，自己尝试就可以了" class="headerlink" title="效果就不演示了，自己尝试就可以了"></a>效果就不演示了，自己尝试就可以了</h2><h2 id="制作特征码"><a href="#制作特征码" class="headerlink" title="制作特征码"></a>制作特征码</h2><p>ce记得搜索数组的时候将可写的选项去除</p><p>个人用户撤回2的头部是在im.dll中特征码 [55 8b ec 81 EC * * * * A1 * * * * 33 c5 89 45 fc 8b 45 0c 33 c9 53 8b 5d 08 56]的第二条</p><p>群用户撤回3的头部是在im.dll中特征码[55 8b ec 81 EC * * * * A1 * * * * 33 c5 89 45 fc 8b 45 0c 33 c9 53 8b 5d 08 56]的第三条</p><hr><h1 id="微信防撤回"><a href="#微信防撤回" class="headerlink" title="微信防撤回"></a>微信防撤回</h1><h2 id="在所有模块中查找revoke并且全部下断"><a href="#在所有模块中查找revoke并且全部下断" class="headerlink" title="在所有模块中查找revoke并且全部下断"></a>在所有模块中查找revoke并且全部下断</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/1_d19ac29f36e65062ddee691e05b8a029.jpg"></p><h2 id="发现断在这些断点上-1"><a href="#发现断在这些断点上-1" class="headerlink" title="发现断在这些断点上"></a>发现断在这些断点上</h2><p>在消息撤回前会断在</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2_7da191449747b314dd522030d39bce4d.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2_7da191449747b314dd522030d39bce4d.jpg"></p><h2 id="发现esp操作类似于内联函数，找到关键跳转"><a href="#发现esp操作类似于内联函数，找到关键跳转" class="headerlink" title="发现esp操作类似于内联函数，找到关键跳转"></a>发现esp操作类似于内联函数，找到关键跳转</h2><p>将关键跳转nop</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/3_bd903b5d65e7f145a1e3aadc7223084d.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/3_bd903b5d65e7f145a1e3aadc7223084d.jpg"></p><h2 id="效果就不演示了，用户以及群都是走的这个函数"><a href="#效果就不演示了，用户以及群都是走的这个函数" class="headerlink" title="效果就不演示了，用户以及群都是走的这个函数"></a>效果就不演示了，用户以及群都是走的这个函数</h2><h2 id="制作特征码-1"><a href="#制作特征码-1" class="headerlink" title="制作特征码"></a>制作特征码</h2><p>关键跳转的特征码是[74 * BE * * * * E9 * * * * 83EC * 8B C4 56 57 c7]的第二条</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qq与微信逆向 </tag>
            
            <tag> qq与微信防撤回 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章发布的细节</title>
      <link href="/2023/04/14/hello-world/"/>
      <url>/2023/04/14/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Front-matter-的基本认识"><a href="#Front-matter-的基本认识" class="headerlink" title="Front-matter 的基本认识"></a>Front-matter 的基本认识</h2><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p><p>其中又分为两种</p><div class="tabs" id="myfront-matter"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#myfront-matter-1">Page Front-matter</button></li><li class="tab"><button type="button" data-href="#myfront-matter-2">Post Front-matter</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="myfront-matter-1"><ul><li>Page Front-matter 用于页面配置</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">type:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标签、分类、关于、音乐馆、友情链接、相册、相册详情、朋友圈、即刻页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="myfront-matter-2"><ul><li>Post Front-matter 用于文章页配置</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">aside:</span><br><span class="line">swiper<span class="emphasis">_index: 1</span></span><br><span class="line"><span class="emphasis">top_</span>group<span class="emphasis">_index: 1</span></span><br><span class="line"><span class="emphasis">background: &quot;#fff&quot;</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标签</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置 top_img,文章页顶部将显示缩略图，可设为 false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章 TOC(默认为设置中 toc 的 enable 配置)</td></tr><tr><td>toc_number</td><td>【可选】显示 toc_number(默认为设置中 toc 的 number 配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中 post_copyright 的 enable 配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的<code>文章作者</code></td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的<code>文章作者</code>链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的<code>文章链接</code>链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的<code>音乐</code> 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>swiper_index</td><td>【可选】首页轮播图配置 index 索引，数字越小越靠前</td></tr><tr><td>top_group_index</td><td>【可选】首页右侧卡片组配置, 数字越小越靠前</td></tr><tr><td>background</td><td>【可选】文章背景可配置为 16 进制颜色值</td></tr></tbody></table><ol><li>首页轮播图配置: <code>swiper_index</code>, 数字越小越靠前</li><li>首页卡片配置: <code>top_group_index</code>, 数字越小越靠前</li><li>page 中 <code>background</code>, 可配置为 16 进制颜色值</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>只需要在你的文章顶部的<code>Front-matter</code>配置这两个字段即可显示轮播图和推荐卡片</p><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p><code>hexo-generator-index</code> 从 2.0.0 开始，已经支持文章置顶功能。你可以直接在文章的 <code>front-matter</code> 区域里添加 <code>sticky: 1</code> 属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><h2 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h2><p>文章的 markdown 文档上,在 Front-matter 添加 cover ,并填上要显示的图片地址。</p><p>如果不配置 cover,可以设置显示默认的 cover。如果不想在首页显示 cover, 可以设置为 false。</p><p><code>文章封面的获取顺序 Front-matter 的 cover &gt; 配置文件的 default_cover &gt; false</code></p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 封面显示的位置</span></span><br><span class="line">  <span class="comment"># 三个值可配置 left , right , both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span></span><br><span class="line">  <span class="comment"># 当没有设置cover时，默认的封面显示</span></span><br><span class="line">  <span class="attr">default_cover:</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>index_enable</td><td>主页是否显示文章封面图</td></tr><tr><td>aside_enable</td><td>侧栏是否显示文章封面图</td></tr><tr><td>archives_enable</td><td>归档页面是否显示文章封面图</td></tr><tr><td>position</td><td>主页卡片文章封面的显示位置-left：全部显示在左边-right：全部显示在右边-both：封面位置以左右左右轮流显示</td></tr><tr><td>default_cover</td><td>默认的 cover, 可配置图片链接&#x2F;顔色&#x2F;渐变色等</td></tr></tbody></table><p>当配置多张图片时,会随机选择一张作为 cover.此时写法应为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg2.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg3.png</span></span><br></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><div class="note warning flat"><p>当文章封面设置为 false 时，或者没有获取到封面配置，相关文章背景将会显示主题色。</p></div><p>相关文章推荐的原理是根据文章 <code>tags</code> 的比重来推荐</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示推荐文章数目</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># or created or updated 文章日期显示创建日或者更新日</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/anzhiyu_048c70d031684a305bb5065f91485bc5.png" alt="&#39;&#39;"></p><h2 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h2><div class="note info flat"><p>标签外挂是 Hexo 独有的功能，并不是标准的 Markdown 格式。<br>以下的写法，只适用于 AnZhiYu 主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意</p></div><div class="note warning flat"><p>标签外挂虽然能为主题带来一些额外的功能和 UI 方面的强化，但是，标签外挂也有明显的限制，使用时请留意。</p></div><p><strong><strong>Note (Bootstrap Callout)</strong></strong></p><p><code>flat样式</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p><code>样式预览</code></p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p><strong><strong>Tab</strong></strong></p><p><code>Tab样式</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><code>样式预览</code></p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong><strong>站外链接 tag</strong></strong><br><code>站外链接样式</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% link 获取网站的Favicon图标并显示在你的网页上,owen0o0,https://github.com/owen0o0/getFavicon %&#125;</span><br></pre></td></tr></table></figure><p><code>样式预览</code></p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://github.com/owen0o0/getFavicon">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/github.com/owen0o0/getFavicon.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">获取网站的Favicon图标并显示在你的网页上</div>            <div class="tag-link-sitename">owen0o0</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></div>]]></content>
      
      
      <categories>
          
          <category> 部署工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章发布的细节 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
