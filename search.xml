<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>特征码定位</title>
      <link href="/2023/04/29/%E7%89%B9%E5%BE%81%E7%A0%81%E5%AE%9A%E4%BD%8D/"/>
      <url>/2023/04/29/%E7%89%B9%E5%BE%81%E7%A0%81%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="特征码定位的算法"><a href="#特征码定位的算法" class="headerlink" title="特征码定位的算法"></a>特征码定位的算法</h2><p>一般特征码定位包括的算法有几种包括：</p><ol><li>暴力搜索</li><li>Kmp算法</li><li>SunDay算法</li><li>BM算法</li><li>······</li></ol><h2 id="关于实现Kmp算法和SunDay算法以及暴力搜索的源码"><a href="#关于实现Kmp算法和SunDay算法以及暴力搜索的源码" class="headerlink" title="关于实现Kmp算法和SunDay算法以及暴力搜索的源码"></a>关于实现Kmp算法和SunDay算法以及暴力搜索的源码</h2><div class="note info flat"><p>暴力搜索</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">voilentSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pat,<span class="type">const</span> <span class="type">char</span>* txt)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(txt);</span><br><span class="line"><span class="type">int</span> m = <span class="built_in">strlen</span>(pat);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(txt[i + j] != pat[j])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == m)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>Kmp算法</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pat, <span class="type">const</span> <span class="type">char</span>* text,vector&lt;<span class="type">int</span>&gt; next)</span></span>&#123; </span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(text))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pat[j])</span><br><span class="line">        &#123;</span><br><span class="line">++i; </span><br><span class="line">++j; </span><br><span class="line"><span class="keyword">if</span> (j==<span class="built_in">strlen</span>(pat)) &#123;</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">j = next[j]; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>SunDay算法</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SunDaySearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* 字串, <span class="type">const</span> <span class="type">char</span>* 主串)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(字串);</span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">strlen</span>(主串);</span><br><span class="line">    <span class="type">int</span> next[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">next[i] = len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">next[字串[i]] = len - i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len2 - len)</span><br><span class="line">    &#123;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (主串[i + j] == 字串[j])</span><br><span class="line">        &#123;</span><br><span class="line">j++;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= len)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i += next[主串[i + len]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于算法实现特征码定位"><a href="#基于算法实现特征码定位" class="headerlink" title="基于算法实现特征码定位"></a>基于算法实现特征码定位</h2><ul><li>暴力搜索实现定位</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchMemory</span><span class="params">(HANDLE hProcess, WORD FeatureCode[], BYTE FeatureCodeSize, DWORD64 StartAddress, DWORD64 EndAddress, std::vector&lt;DWORD64&gt;&amp; ResultArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MEMORY_BASIC_INFORMATION MemoryInformation;</span><br><span class="line">FeatureCodeSize -= <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">VirtualQueryEx</span>(hProcess, (LPCVOID)StartAddress, &amp;MemoryInformation, <span class="built_in">sizeof</span>(MemoryInformation)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (MemoryInformation.Protect == PAGE_EXECUTE_READ || MemoryInformation.Protect == PAGE_EXECUTE_READWRITE || MemoryInformation.Protect== PAGE_READWRITE) &#123;</span><br><span class="line">BYTE* MemoryData = <span class="keyword">new</span> BYTE[MemoryInformation.RegionSize];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, MemoryInformation.BaseAddress, MemoryData, MemoryInformation.RegionSize, <span class="literal">nullptr</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">MemoryInformation.RegionSize-=FeatureCodeSize;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; MemoryInformation.RegionSize; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;=FeatureCodeSize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (MemoryData[v+i]!=FeatureCode[i] &amp;&amp; FeatureCode[i]&lt;=<span class="number">255</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i == FeatureCodeSize)</span><br><span class="line">&#123;</span><br><span class="line">ResultArray.<span class="built_in">push_back</span>((DWORD64)MemoryInformation.BaseAddress+v);</span><br><span class="line">i += FeatureCodeSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] MemoryData;</span><br><span class="line">&#125;</span><br><span class="line">StartAddress = (DWORD64)MemoryInformation.BaseAddress + MemoryInformation.RegionSize + FeatureCodeSize + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (StartAddress&gt;=EndAddress) &#123;</span><br><span class="line"><span class="keyword">return</span> ResultArray.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HANDLE handle=<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE,<span class="number">15968</span>);</span><br><span class="line">WORD FeatureCode[] = &#123;<span class="number">0xD8</span>,<span class="number">00</span>,<span class="number">0xB8</span>,<span class="number">0x256</span>&#125;;<span class="comment">//0x256 代表是特征码中的??</span></span><br><span class="line">std::vector&lt;DWORD64&gt;ResultArray;</span><br><span class="line"><span class="type">int</span> number=<span class="built_in">SearchMemory</span>(handle, FeatureCode,<span class="built_in">sizeof</span>(FeatureCode),<span class="number">0x41000</span>,<span class="number">0x7ffffffff</span>, ResultArray);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ResultArray.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>, ResultArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数量是%d&quot;</span>, number);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SunDay算法实现定位</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKMAXSIZE 409600<span class="comment">//每次读取内存的最大大小</span></span></span><br><span class="line">BYTE* MemoryData;<span class="comment">//每次将读取的内存读入这里</span></span><br><span class="line"><span class="type">short</span> Next[<span class="number">260</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//特征码转字节集</span></span><br><span class="line"><span class="function">WORD <span class="title">GetTzmArray</span><span class="params">(<span class="type">char</span>* Tzm, WORD* TzmArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">WORD TzmLength = <span class="built_in">strlen</span>(Tzm) / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(Tzm); )<span class="comment">//将十六进制特征码转为十进制</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> num[<span class="number">2</span>];</span><br><span class="line">num[<span class="number">0</span>] = Tzm[i++];</span><br><span class="line">num[<span class="number">1</span>] = Tzm[i++];</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (num[<span class="number">0</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; num[<span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">WORD a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; num[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = num[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; num[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = num[i] - <span class="number">87</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; num[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = num[i] - <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sum = a[<span class="number">0</span>] * <span class="number">16</span> + a[<span class="number">1</span>];</span><br><span class="line">TzmArray[len++] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TzmArray[len++] = <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TzmLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">short</span>* next, WORD* Tzm, WORD TzmLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//特征码（字节集）的每个字节的范围在0-255（0-FF）之间，256用来表示问号，到260是为了防止越界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">260</span>; i++)</span><br><span class="line">next[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TzmLength; i++)</span><br><span class="line">next[Tzm[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索一块内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchMemoryBlock</span><span class="params">(HANDLE hProcess, WORD* Tzm, WORD TzmLength, <span class="type">unsigned</span> __int64 StartAddress, <span class="type">unsigned</span> <span class="type">long</span> size, vector&lt;<span class="type">unsigned</span> __int64&gt;&amp; ResultArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)StartAddress, MemoryData, size, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j, k; i &lt; size;)</span><br><span class="line">&#123;</span><br><span class="line">j = i; k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; k &lt; TzmLength &amp;&amp; j &lt; size &amp;&amp; (Tzm[k] == MemoryData[j] || Tzm[k] == <span class="number">256</span>); k++, j++);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == TzmLength)</span><br><span class="line">&#123;</span><br><span class="line">ResultArray.<span class="built_in">push_back</span>(StartAddress + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((i + TzmLength) &gt;= size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = Next[MemoryData[i + TzmLength]];</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">-1</span>)</span><br><span class="line">i += (TzmLength - Next[<span class="number">256</span>]);<span class="comment">//如果特征码有问号，就从问号处开始匹配，如果没有就i+=-1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i += (TzmLength - num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索整个程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchMemory</span><span class="params">(HANDLE hProcess, <span class="type">char</span>* Tzm, <span class="type">unsigned</span> __int64 StartAddress, <span class="type">unsigned</span> __int64 EndAddress, <span class="type">int</span> InitSize, vector&lt;<span class="type">unsigned</span> __int64&gt;&amp; ResultArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> BlockSize;</span><br><span class="line">MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line"></span><br><span class="line">WORD TzmLength = <span class="built_in">strlen</span>(Tzm) / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">WORD* TzmArray = <span class="keyword">new</span> WORD[TzmLength];</span><br><span class="line"></span><br><span class="line"><span class="built_in">GetTzmArray</span>(Tzm, TzmArray);</span><br><span class="line"><span class="built_in">GetNext</span>(Next, TzmArray, TzmLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化结果数组</span></span><br><span class="line">ResultArray.<span class="built_in">clear</span>();</span><br><span class="line">ResultArray.<span class="built_in">reserve</span>(InitSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">VirtualQueryEx</span>(hProcess, (LPCVOID)StartAddress, &amp;mbi, <span class="built_in">sizeof</span>(mbi)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取可读可写和可读可写可执行的内存块</span></span><br><span class="line"><span class="keyword">if</span> (mbi.Protect == PAGE_READWRITE || mbi.Protect == PAGE_EXECUTE_READWRITE)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">BlockSize = mbi.RegionSize;</span><br><span class="line"><span class="comment">//搜索这块内存</span></span><br><span class="line"><span class="keyword">while</span> (BlockSize &gt;= BLOCKMAXSIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SearchMemoryBlock</span>(hProcess, TzmArray, TzmLength, StartAddress + (BLOCKMAXSIZE * i), BLOCKMAXSIZE, ResultArray);</span><br><span class="line">BlockSize -= BLOCKMAXSIZE; i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SearchMemoryBlock</span>(hProcess, TzmArray, TzmLength, StartAddress + (BLOCKMAXSIZE * i), BlockSize, ResultArray);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">StartAddress += mbi.RegionSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EndAddress != <span class="number">0</span> &amp;&amp; StartAddress &gt; EndAddress)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ResultArray.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(TzmArray);</span><br><span class="line"><span class="keyword">return</span> ResultArray.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetAddress</span><span class="params">(DWORD pid ,<span class="type">char</span>* Tzm, <span class="type">unsigned</span> __int64 StartAddress, <span class="type">unsigned</span> __int64 EndAddress, vector&lt;<span class="type">unsigned</span> __int64&gt;&amp;ResultArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化MemoryData大小</span></span><br><span class="line">MemoryData = <span class="keyword">new</span> BYTE[BLOCKMAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过进程ID获取进程句柄</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">false</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SearchMemory</span>(hProcess, Tzm, StartAddress, EndAddress, <span class="number">255</span>, ResultArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">unsigned</span> __int64&gt; ResultArray;</span><br><span class="line">DWORD pid = 填写进程PID;</span><br><span class="line"><span class="built_in">GetAddress</span>(pid, (<span class="type">char</span>*)<span class="string">&quot;76 80 FB A0 76 F0 0B 9E 76 C0 F2 9D 76 20 F0 9D 76 30&quot;</span>, <span class="number">0x410000</span>, <span class="number">0xFFFFFFFF</span>, ResultArray);</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">unsigned</span> __int64&gt;::iterator it = ResultArray.<span class="built_in">begin</span>(); it != ResultArray.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, *it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kmp算法在搜寻特征码时慢于前两者，就不贴源码了，BM与SunDay运行效率差不多</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征码定位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(三)</title>
      <link href="/2023/04/27/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
      <url>/2023/04/27/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h2 id="驱动设备与符号链接"><a href="#驱动设备与符号链接" class="headerlink" title="驱动设备与符号链接"></a>驱动设备与符号链接</h2><h3 id="设备名称与符号链接名称说明"><a href="#设备名称与符号链接名称说明" class="headerlink" title="设备名称与符号链接名称说明"></a>设备名称与符号链接名称说明</h3><p>windows下的设备是以”&#x2F;Device&#x2F;[设备名]”形式命名的。例如磁盘分区的c盘，d盘的设备名称就是”&#x2F;Device&#x2F;HarddiskVolume1”,”&#x2F;Device&#x2F;HarddiskVolume2”, 当然也可以不指定设备名称。如果IoCreateDevice中没有指定设备名称，那么I&#x2F;O管理器会自动分配一个数字作为设备的名称。例如”&#x2F;Device&#x2F;00000001”。&#x2F;Device&#x2F;[设备名]，不容易记忆，通常符号链接可以理解为设备的别名，更重要的是设备名，只能被内核模式下的其他驱动所识别，而别名可以被用户模式下的应用程序识别，例如c盘，就是名为”c:”的符号链接，其真正的设备对象是”&#x2F;Device&#x2F;HarddiskVolume1”，所以在写驱动时候，一般我们创建符号链接，即使驱动中没有用到，这也算是一个好的习惯吧。<br>驱动中符号链接名是这样写的<br>L”&#x2F;&#x2F;??&#x2F;&#x2F;HelloDDK” —&gt;&#x2F;??&#x2F;HelloDDK<br>L”&#x2F;&#x2F;DosDevices&#x2F;&#x2F;HelloDDK”—&gt;&#x2F;DosDevices&#x2F;HelloDDK<br>在应用程序中，符号链接名：<br>L”.&#x2F;&#x2F;HelloDDK”–&gt;&#x2F;&#x2F;.&#x2F;HelloDDK</p><p>winobj和DeviceTree可以用来查看这些信息。</p><p>DosDevices的符号链接名就是??, 所以”&#x2F;&#x2F;DosDevices&#x2F;&#x2F;XXXX”其实就是”&#x2F;&#x2F;??&#x2F;&#x2F;XXXX”</p><h3 id="创建设备与符号链接的步骤"><a href="#创建设备与符号链接的步骤" class="headerlink" title="创建设备与符号链接的步骤"></a>创建设备与符号链接的步骤</h3><ol><li>将<code>\\DEVICE\\MyDriver</code>驱动设备名称赋值给MyDriver</li><li>通过IoCreateDevice来创建设备对象</li><li>再将<code>\\??\\MyDriver</code>符号链接名称赋值给uzSymbolName</li><li>再通过IoCreateSymbolicLink来创建符号链接</li><li>R3层就只需要调用CreateFileW或CreateFile来获得句柄</li><li>删除的话需要先通过IoDeleteSymbolicLink删除符号链接再IoDeleteDevice删除设备</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;<span class="comment">//用于存放设备对象</span></span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\DEVICE\\MyDriver&quot;</span>);<span class="comment">//驱动设备名字</span></span><br><span class="line"></span><br><span class="line">status = IoCreateDevice(driver, <span class="keyword">sizeof</span>(driver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS)<span class="comment">//STATUS_SUCCESS)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建成功，OK \n&quot;</span>));</span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">UNICODE_STRING uzSymbolName; <span class="comment">//符号链接名字 </span></span><br><span class="line">RtlInitUnicodeString(&amp;uzSymbolName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>); <span class="comment">//CreateFile</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;uzSymbolName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;uzSymbolName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;uzSymbolName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-R0层"><a href="#完整代码-R0层" class="headerlink" title="完整代码-R0层"></a>完整代码-R0层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DeviceIrpCtl</span><span class="params">(PDEVICE_OBJECT device, PIRP pirp)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数&quot;</span>));</span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line">ULONG CtlCode;</span><br><span class="line">ULONG InputBuffLength;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp); <span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL: <span class="comment">//DeviceIoControl</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了 DeviceIoControl&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE: <span class="comment">//CreateFile</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了 CreateFile&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE: <span class="comment">//CloseHandle</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了 CloseHandle&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的 倒数第二个参数lpBytesReturned</span></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级 </span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DeviceIrpCtl_Close</span><span class="params">(PDEVICE_OBJECT device, PIRP pirp)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数 DeviceIrpCtl_Close&quot;</span>));</span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line">ULONG CtlCode;</span><br><span class="line">ULONG InputBuffLength;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp); <span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line">  KdPrint((<span class="string">&quot;yjx:用户层调用了 CloseHandle DeviceIrpCtl_Close&quot;</span>));</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的 倒数第二个参数lpBytesReturned</span></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级 </span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数 DeviceIrpCtl_Close&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建驱动设备对象</span></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING MyDriver;</span><br><span class="line">PDEVICE_OBJECT device;<span class="comment">//用于存放设备对象</span></span><br><span class="line">RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\DEVICE\\MyDriver&quot;</span>);<span class="comment">//驱动设备名字</span></span><br><span class="line"></span><br><span class="line">status = IoCreateDevice(driver, <span class="keyword">sizeof</span>(driver-&gt;DriverExtension), &amp;MyDriver, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;device);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS)<span class="comment">//STATUS_SUCCESS)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建成功，OK \n&quot;</span>));</span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">UNICODE_STRING uzSymbolName; <span class="comment">//符号链接名字 </span></span><br><span class="line">RtlInitUnicodeString(&amp;uzSymbolName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>); <span class="comment">//CreateFile</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;uzSymbolName, &amp;MyDriver);</span><br><span class="line"><span class="keyword">if</span> (status == STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 成功 &quot;</span>, &amp;uzSymbolName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:创建符号链接 %wZ 失败 status=%X&quot;</span>, &amp;uzSymbolName, status));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:驱动设备对象创建失败，删除设备\n&quot;</span>));</span><br><span class="line">IoDeleteDevice(device);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnLoad</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入了 DriverUnLoad例程&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (pDriver-&gt;DeviceObject)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除符号链接</span></span><br><span class="line"> </span><br><span class="line">UNICODE_STRING uzSymbolName; <span class="comment">//符号链接名字 </span></span><br><span class="line">RtlInitUnicodeString(&amp;uzSymbolName, <span class="string">L&quot;\\??\\MyDriver&quot;</span>); <span class="comment">//CreateFile</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除符号链接=%wZ&quot;</span>,&amp;uzSymbolName));</span><br><span class="line">IoDeleteSymbolicLink(&amp;uzSymbol);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:删除驱动设备&quot;</span>));</span><br><span class="line">IoDeleteDevice(pDriver-&gt;DeviceObject);<span class="comment">//删除设备对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:退出 DriverUnLoad例程&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver,PUNICODE_STRING szReg)</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:我的第一个驱动,注册路径=%wZ&quot;</span>, szReg));</span><br><span class="line">driver-&gt;DriverUnload = DriverUnLoad;</span><br><span class="line"><span class="comment">//为驱动对象创建一个设备</span></span><br><span class="line">NTSTATUS status = CreateDevice(driver);<span class="comment">//</span></span><br><span class="line"><span class="comment">//注册IRP处理 例程</span></span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_CREATE] = DeviceIrpCtl; <span class="comment">//CreateFile</span></span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_CLOSE] = DeviceIrpCtl_Close;<span class="comment">//卸载驱动 CloseHandle</span></span><br><span class="line">driver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIrpCtl;<span class="comment">//DeviceIoControl</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-R3层"><a href="#完整代码-R3层" class="headerlink" title="完整代码-R3层"></a>完整代码-R3层</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Window.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HANDLE DeviceHandle = <span class="built_in">CreateFileW</span>(</span><br><span class="line"><span class="string">L&quot;\\??\\MyDriver&quot;</span>,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DeviceHandle是%p&quot;</span>,DeviceHandle);</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="comment">//暂停一下方便看到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%B0%8F%E6%A9%99%E5%AD%90%E7%9A%84win10-2023-04-27-00-31-52_6e8b0cf1d60a96f404c32d268a018e8b.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(二)</title>
      <link href="/2023/04/26/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
      <url>/2023/04/26/x64%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="驱动框架完善-IRP例程注册"><a href="#驱动框架完善-IRP例程注册" class="headerlink" title="驱动框架完善-IRP例程注册"></a>驱动框架完善-IRP例程注册</h2><h3 id="IRP例程种类及用途"><a href="#IRP例程种类及用途" class="headerlink" title="IRP例程种类及用途"></a>IRP例程种类及用途</h3><p>IRP(I&#x2F;O Request Package) 是输入输出请求包的简称</p><p>IRP_MJ_CREATE   请求一个句柄  CreateFile<br>IRP_MJ_CLOSE    关闭句柄  CloseHandle<br>IRP_MJ_READ     从设备得到数据 ReadFile<br>IRP_MJ_WRITE    传送数据到设备 WriteFile<br>IRP_MJ_DEVICE_CONTROL 控制操作利用IOCTL宏  DeviceIoControl</p><h3 id="IRP例程注册方式"><a href="#IRP例程注册方式" class="headerlink" title="IRP例程注册方式"></a>IRP例程注册方式</h3><p>例如<code>Pdriver-&gt;MajorFunction[IRP_MJ_CREATE]=指定函数</code></p><p>指定函数中必须包含PDEVICE_OBJECT pdevice, PIRP pirp这两个参数</p><h3 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT Pdriver)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:卸载成功\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">IRP_Call</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pirp)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是PDEVICE_OBJECT，不要写成了PDRIVER_OBJECT</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:进入派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">PIO_STACK_LOCATION irpStackL;</span><br><span class="line"></span><br><span class="line">irpStackL = IoGetCurrentIrpStackLocation(pirp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (irpStackL-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CreateFile\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_CLOSE:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了CloseHandle\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:用户层调用了DeviceIoControl\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">pirp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpBytesReturned</span></span><br><span class="line"></span><br><span class="line">IoCompleteRequest(pirp, IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作 并且不增加优先级</span></span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:离开派遣函数\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Pdriver, PUNICODE_STRING prestring)</span> &#123;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:加载成功\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">Pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = IRP_Call;</span><br><span class="line"></span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = IRP_Call;</span><br><span class="line"></span><br><span class="line">Pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IRP_Call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成IRP的例程注册，后期可以写单独的函数方便R0层与R3层通信</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x64驱动学习(一)</title>
      <link href="/2023/04/24/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
      <url>/2023/04/24/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装VS2019"><a href="#安装VS2019" class="headerlink" title="安装VS2019"></a>安装VS2019</h2><blockquote><p>下载Visual Studio Installer, 安装时工作负载选择 使用C++的桌面开发 。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2021010419162676_7dff4df4aaefad23de4961d37c91281f.png"></p></blockquote><blockquote><p>由于WDK 默认启用了 Spectre 缓解，需要在单个组件中添加生成工具对应版本的 Spectre 缓解库 。(这里只下载了x64&#x2F;x86处理器架构)</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104194224503_d3796ca6116cd74095f18f3ecd8d9518.png"></p></blockquote><h2 id="安装WDK"><a href="#安装WDK" class="headerlink" title="安装WDK"></a>安装WDK</h2><p>下载的 WDK 需要与 VS 2019下载时的 Windows 10 SDK 版本对应</p><blockquote><p>我这里下载的WDK所要求的版本号为 Windows 10 SDK (10.0.19041.685)。<br>在 Windows设置-应用 中可以查看当前安装的SDK与WDK版本是否一致，不一致可以到官网下载对应的版本。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104211649239_dcc591f2a0bc05df16e39514c7483c88.png"></p><p>以上都可以直接在官网下载:<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk">参考链接</a></p></blockquote><blockquote><p>等待WDK下载安装完成，关闭时默认选择安装 WDK VS 扩展。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104201951315_5e723f775c27b80332405470d3a9de2e.png"></p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104202210555_94c25096f97b250e8897e99cddb04c9b.png"></p><p>如果WDK安装完成后没有安装WDK VS 扩展，可以在WDK安装目录 <strong>Windows Kits\10\Vsix</strong> 中找到 <strong>WDK.vsix</strong> 文件双击打开。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210105001920314_3104266225459460f7ae48a18c712cc3.png"></p></blockquote><blockquote><p>所有安装完成后，打开VS2019，创建新项目中会出现 Driver 这一项，下面就可以进行驱动程序开发了。</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104203550420_58440d51d37b6547776e05b987a347ea.png"></p></blockquote><h1 id="一个简单的HelloWorld驱动程序"><a href="#一个简单的HelloWorld驱动程序" class="headerlink" title="一个简单的HelloWorld驱动程序"></a>一个简单的HelloWorld驱动程序</h1><blockquote><p>新建Empty WDM Driver项目</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/20210104213043805_5b4fdad63521319b00e5ce8a94a17d26.png"></p></blockquote><blockquote><p>添加源文件 driver.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ntddk.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ntifs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pdriver)</span> &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;jyx:卸载成功\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pregister)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//内核打印需要KdPrint，并且需要两个括号</span></span><br><span class="line">KdPrint((<span class="string">&quot;jyx:HelloWorld\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定卸载函数</span></span><br><span class="line">pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><em><strong><strong>编译前</strong></strong></em></p><p>a.移除项目自动生成的.inf文件<br>b.配置属性 - C&#x2F;C++ -常规<br>警告等级 设置为 等级3<br>将警告视为错误 设置为 否</p><p>c.配置属性 - 链接器 -常规<br>将链接器警告视为错误 设置为 否</p><p>d.配置属性 - Driver Signing - General<br>Sign Mode 设置为 Off。</p><p>e.配置属性 - Inf2Cat - Run Inf2Cat设置为否</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x64驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信多开</title>
      <link href="/2023/04/23/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80/"/>
      <url>/2023/04/23/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="修改微信源文件实现多开"><a href="#修改微信源文件实现多开" class="headerlink" title="修改微信源文件实现多开"></a>修改微信源文件实现多开</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>计算机程序为避免多开，一般选择Mutex(互斥锁)、Event(事件)、Semaphore(信号量)、窗口、文件</p><h2 id="对这些常用系统api下断"><a href="#对这些常用系统api下断" class="headerlink" title="对这些常用系统api下断"></a>对这些常用系统api下断</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%801_ea7dc8abd2f15e23a114443dc6d492be.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/微信多开1_ea7dc8abd2f15e23a114443dc6d492be.jpg"></p><p>在x32dbg中ctrl+g去到CreateMutexW中，在CreateMutexW的地址附近对于CreateSemaphoreExW、CreateSemaphorew、CreateMutexExA、CreateMutexA、CreateEventW都下断</p><h2 id="发现断在CreateEventW上"><a href="#发现断在CreateEventW上" class="headerlink" title="发现断在CreateEventW上"></a>发现断在CreateEventW上</h2><p>一直断在CreateEventW上，并且一直断于线程读写、防止线程多开。因此我们尝试放开CreateEventW的断点</p><h2 id="放开后中直接断在CreateMutexW上"><a href="#放开后中直接断在CreateMutexW上" class="headerlink" title="放开后中直接断在CreateMutexW上"></a>放开后中直接断在CreateMutexW上</h2><p>直接Crtl+F9返回，F8步过</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%802_0de25c93b05045db4af30f4fd5e8a2c5.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/微信多开2_0de25c93b05045db4af30f4fd5e8a2c5.jpg"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过CreateMutexW，将CreateMutexW的返回值赋值给esi，在判断esi的数值是否为0，相等跳转，不相等则调用GetLastError，返回值与B7比较，因此直接强制跳转就可以了</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%803_b6388245c8682053d793929a8e344333.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/微信多开3_b6388245c8682053d793929a8e344333.jpg"></p><h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%804_8fb25e682b166a2904692a37ce1b0937.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/微信多开4_8fb25e682b166a2904692a37ce1b0937.jpg"></p><h2 id="效果不演示了"><a href="#效果不演示了" class="headerlink" title="效果不演示了"></a>效果不演示了</h2><p>效果便是一台电脑同时登录多个微信</p><h1 id="不修改源文件，通过互斥名关闭互斥量"><a href="#不修改源文件，通过互斥名关闭互斥量" class="headerlink" title="不修改源文件，通过互斥名关闭互斥量"></a>不修改源文件，通过互斥名关闭互斥量</h1><h2 id="进一步了解CreateMutexW"><a href="#进一步了解CreateMutexW" class="headerlink" title="进一步了解CreateMutexW"></a>进一步了解CreateMutexW</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutexW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bInitialOwner,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCWSTR               lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>第一个参数</strong>是安全属性结构体， <code>lpMutexAttributes</code> 为 NULL，则 mutex 获取默认的安全描述符。 为NULL即可。<br><strong>第二个参数</strong>是否被继承，如果此值为 TRUE ，并且调用方创建了互斥体，则调用线程获取互斥体对象的初始所有权。 否则，调用线程不会获取互斥体的所有权。为FALSE即可。<br><strong>第三个参数</strong>是<code>互斥体名称</code>，这个参数很关键。<br><strong>返回值</strong> 如果函数成功，则返回值是新创建的互斥体对象的句柄。如果函数失败，则返回值为 NULL。</p><p>找到这个名称对应的互斥体，然后将句柄给它关闭，就能实现多开了。也无需去修改其源代码。</p><h2 id="逆向CreateMutexW的第三个参数"><a href="#逆向CreateMutexW的第三个参数" class="headerlink" title="逆向CreateMutexW的第三个参数"></a>逆向CreateMutexW的第三个参数</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/5/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-01%20000014_83476d30b465e6a67245b27e7066fbb6.jpg"></p><p>微信判断是否多开的互斥体名称是<strong>_WeChat_App_Instance_Identity_Mutex_Name</strong></p><h2 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义需要的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_SUCCESS 0x00UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_INFO_LENGTH_MISMATCH 0xC0000004</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemHandleInformation 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_DEBUG_PRIVILEGE 0x14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义需要用到的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_OBJECT_INFORMATION_CLASSEX</span> &#123;</span><br><span class="line">    ObjBasicInformation = <span class="number">0</span>,</span><br><span class="line">    ObjNameInformation,</span><br><span class="line">    ObjTypeInformation,</span><br><span class="line">&#125; OBJECT_INFORMATION_CLASSEX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_PROCESSINFOCLASSEX</span></span><br><span class="line">&#123;</span><br><span class="line">    ProcessHandleInformation = <span class="number">20</span>,</span><br><span class="line">&#125;PROCESSINFOCLASSEX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG ProcessId;</span><br><span class="line">    BYTE ObjectTypeNumber;</span><br><span class="line">    BYTE Flags;</span><br><span class="line">    USHORT Handle;</span><br><span class="line">    PVOID Object;</span><br><span class="line">    ACCESS_MASK GrantAccess;</span><br><span class="line">&#125;SYSTEM_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE_INFORMATION</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD HandleCount;</span><br><span class="line">    SYSTEM_HANDLE Handles[<span class="number">1</span>];</span><br><span class="line">&#125;SYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OBJECT_NAME_INFORMATION</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING ObjectName;</span><br><span class="line">&#125;OBJECT_NAME_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明未导出API</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* ZwQueryInformationProcessProc)</span><span class="params">(HANDLE, PROCESSINFOCLASSEX, LPVOID, DWORD, PDWORD)</span></span>;</span><br><span class="line">ZwQueryInformationProcessProc ZwQueryInformationProcess;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* ZwQuerySystemInformationProc)</span><span class="params">(DWORD, PVOID, DWORD, DWORD*)</span></span>;</span><br><span class="line">ZwQuerySystemInformationProc ZwQuerySystemInformation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* ZwQueryObjectProc)</span><span class="params">(HANDLE, OBJECT_INFORMATION_CLASSEX, PVOID, ULONG, PULONG)</span></span>;</span><br><span class="line">ZwQueryObjectProc ZwQueryObject;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* RtlAdjustPrivilegeProc)</span><span class="params">(DWORD, BOOL, BOOL, PDWORD)</span></span>;</span><br><span class="line">RtlAdjustPrivilegeProc RtlAdjustPrivilege;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* ZwSuspendProcessProc)</span><span class="params">(HANDLE)</span></span>;</span><br><span class="line">ZwSuspendProcessProc ZwSuspendProcess;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* ZwResumeProcessProc)</span><span class="params">(HANDLE)</span></span>;</span><br><span class="line">ZwResumeProcessProc ZwResumeProcess;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable: 6011) </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable: 6001) </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable: 6387) </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提升进程权限</span></span><br><span class="line"><span class="function">BOOL <span class="title">ElevatePrivileges</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    TOKEN_PRIVILEGES tkp;</span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tkp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tkp, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化未导出API</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetUnDocumentAPI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ZwSuspendProcess = (ZwSuspendProcessProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwSuspendProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZwQuerySystemInformation = (ZwQuerySystemInformationProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwQuerySystemInformation&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZwQueryObject = (ZwQueryObjectProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwQueryObject&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZwResumeProcess = (ZwResumeProcessProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwResumeProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZwQueryInformationProcess = (ZwQueryInformationProcessProc)</span><br><span class="line">        <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwQueryInformationProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ZwSuspendProcess == <span class="literal">NULL</span>) || \</span><br><span class="line">        (ZwQuerySystemInformation == <span class="literal">NULL</span>) || \</span><br><span class="line">        (ZwQueryObject == <span class="literal">NULL</span>) || \</span><br><span class="line">        (ZwResumeProcess == <span class="literal">NULL</span>) || \</span><br><span class="line">        (ZwQueryInformationProcess == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭指定Mutex s</span></span><br><span class="line"><span class="function">BOOL <span class="title">closeMutexHandle</span><span class="params">(UINT Proc_id, <span class="type">const</span> <span class="type">wchar_t</span>* Mutex_name)</span> </span>&#123;</span><br><span class="line">    HANDLE duplicateHnd, sourceHnd = <span class="number">0</span>;</span><br><span class="line">    DWORD procHndNum;</span><br><span class="line">    SYSTEM_HANDLE* currnetHnd;</span><br><span class="line">    DWORD buffLen = <span class="number">0x1000</span>;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    SYSTEM_HANDLE_INFORMATION* buff = (SYSTEM_HANDLE_INFORMATION*)<span class="built_in">malloc</span>(buffLen);</span><br><span class="line">    UINT count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">ElevatePrivileges</span>() == FALSE) || (<span class="built_in">GetUnDocumentAPI</span>() == FALSE))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="built_in">ZwQuerySystemInformation</span>(SystemHandleInformation, buff, buffLen, &amp;buffLen);</span><br><span class="line">        <span class="keyword">if</span> (status == STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(buff);</span><br><span class="line">            buff = (SYSTEM_HANDLE_INFORMATION*)<span class="built_in">malloc</span>(buffLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    OBJECT_NAME_INFORMATION* objNameInfo = (OBJECT_NAME_INFORMATION*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    OBJECT_NAME_INFORMATION* objTypeInfo = (OBJECT_NAME_INFORMATION*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; (<span class="type">int</span>)buff-&gt;HandleCount; idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        currnetHnd = &amp;(buff-&gt;Handles[idx]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currnetHnd-&gt;ProcessId == Proc_id)</span><br><span class="line">        &#123;</span><br><span class="line">            sourceHnd = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS | PROCESS_DUP_HANDLE | PROCESS_SUSPEND_RESUME, FALSE, Proc_id);</span><br><span class="line">            (ZwSuspendProcess)(sourceHnd);</span><br><span class="line">            (ZwQueryInformationProcess)(sourceHnd, ProcessHandleInformation, &amp;procHndNum, <span class="built_in">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//进程有效句柄从4开始,每次以4递增</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> hndNum = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; (<span class="type">int</span>)procHndNum; hndNum += <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断是否为有效句柄，返回TRUE，就是有效句柄</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">DuplicateHandle</span>(sourceHnd,</span><br><span class="line">                    (HANDLE)hndNum,</span><br><span class="line">                    <span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">                    &amp;duplicateHnd, <span class="number">0</span>, FALSE, DUPLICATE_SAME_ACCESS))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">memset</span>(objNameInfo, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">                    <span class="built_in">memset</span>(objTypeInfo, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">ZwQueryObject</span>((HANDLE)duplicateHnd, ObjNameInformation, objNameInfo, <span class="number">0x1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">ZwQueryObject</span>((HANDLE)duplicateHnd, ObjTypeInformation, objTypeInfo, <span class="number">0x1000</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//找到互斥体 比较名字</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">wcscmp</span>(objTypeInfo-&gt;ObjectName.Buffer, <span class="string">L&quot;Mutant&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//OutputDebugString();</span></span><br><span class="line">                        <span class="keyword">if</span> (objNameInfo-&gt;ObjectName.Length != <span class="number">0</span> &amp;&amp; <span class="built_in">wcsstr</span>(objNameInfo-&gt;ObjectName.Buffer, Mutex_name) != <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;%ws\n&quot;</span>, objNameInfo-&gt;ObjectName.Buffer);</span><br><span class="line"></span><br><span class="line">                            <span class="function">wstring <span class="title">str</span><span class="params">(objNameInfo-&gt;ObjectName.Buffer)</span></span>;</span><br><span class="line">                            <span class="type">int</span> pos = str.<span class="built_in">rfind</span>(<span class="string">L&quot;\\&quot;</span>);</span><br><span class="line">                            wstring subStr = str.<span class="built_in">substr</span>(pos + <span class="number">1</span>, <span class="number">40</span>);</span><br><span class="line">                            <span class="keyword">if</span> (subStr == <span class="string">L&quot;_WeChat_App_Instance_Identity_Mutex_Name&quot;</span>) &#123;</span><br><span class="line">                                <span class="built_in">CloseHandle</span>(duplicateHnd);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">DuplicateHandle</span>(sourceHnd,</span><br><span class="line">                                    (HANDLE)hndNum,</span><br><span class="line">                                    <span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">                                    &amp;duplicateHnd, <span class="number">0</span>, FALSE, DUPLICATE_CLOSE_SOURCE))</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="built_in">CloseHandle</span>(duplicateHnd);</span><br><span class="line">                                    (ZwResumeProcess)(sourceHnd);</span><br><span class="line">                                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        count++;</span><br><span class="line">                        <span class="keyword">if</span> (count == <span class="number">20</span>) &#123; <span class="keyword">return</span> FALSE; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">CloseHandle</span>(duplicateHnd);</span><br><span class="line">                    idx++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">findPidByName</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* name)</span> </span>&#123;</span><br><span class="line">    HANDLE hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line">    pe.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="type">bool</span> b = <span class="built_in">Process32First</span>(hSnap, &amp;pe);</span><br><span class="line">    string str;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="comment">//pe.szExeFile;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcscmp</span>(pe.szExeFile, name) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;应用名称%ws,进程id %d\n&quot;</span>, pe.szExeFile, pe.th32ProcessID);</span><br><span class="line">            pId.<span class="built_in">push_back</span>(pe.th32ProcessID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        b = <span class="built_in">Process32Next</span>(hSnap, &amp;pe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ElevatePrivileges</span>();  <span class="comment">//提升当前进程权限</span></span><br><span class="line">    <span class="built_in">GetUnDocumentAPI</span>();    <span class="comment">//初始化未导出API</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pid;</span><br><span class="line"></span><br><span class="line">    pid = <span class="built_in">findPidByName</span>(<span class="string">L&quot;WeChat.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid.<span class="built_in">size</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;微信未打开\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//为空直接跳出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pid[i]);<span class="comment">//\Sessions\2\BaseNamedObjects\SM0:18508:168:WilStaging_02</span></span><br><span class="line">        <span class="built_in">closeMutexHandle</span>(pid[i], <span class="string">L&quot;\\Sessions\\2\\BaseNamedObjects\\_WeChat_App_Instance_Identity_Mutex_Name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 逆向学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信多开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个稳定的图床</title>
      <link href="/2023/04/18/%E6%9C%AC%E6%96%87%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/04/18/%E6%9C%AC%E6%96%87%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>比jsdelivr更加稳定的图床方案（国内图床）</p><h1 id="Github图床和Vika图床"><a href="#Github图床和Vika图床" class="headerlink" title="Github图床和Vika图床"></a>Github图床和Vika图床</h1><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>picgo：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>选择最新版本，然后下载的安装包</p><blockquote><p>注意：下载最新版本即可，如果vika图床无法使用，就卸载降级</p></blockquote><h2 id="Github图床"><a href="#Github图床" class="headerlink" title="Github图床"></a>Github图床</h2><blockquote><p>自定义域名，使用cdn：<a href="https://cdn.staticaly.com/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D@main">https://cdn.staticaly.com/gh/用户名/仓库名@main</a></p></blockquote><h2 id="Vika图床"><a href="#Vika图床" class="headerlink" title="Vika图床"></a>Vika图床</h2><p>vika注册地址：<a href="https://vika.cn/?inviteCode=55733216">https://vika.cn/?inviteCode=55733216</a></p><p>填写我的邀请码可以获得1000V币，3000V币可以找客服扩容</p><blockquote><p>邀请码：55733216</p></blockquote><p>一个空间有1G的容量，每个人只能创一个，一般我也不是很想用这个</p><h3 id="安装vika插件"><a href="#安装vika插件" class="headerlink" title="安装vika插件"></a>安装vika插件</h3><p>直接在picgo安装即可</p><h3 id="配置api和维格表id"><a href="#配置api和维格表id" class="headerlink" title="配置api和维格表id"></a>配置api和维格表id</h3><p>先去账户中心–开发者配置 可以生成你的api token</p><h3 id="记得图片过大将图片进行压缩"><a href="#记得图片过大将图片进行压缩" class="headerlink" title="记得图片过大将图片进行压缩"></a>记得图片过大将图片进行压缩</h3><blockquote><p>直接搜索在线图片压缩如<a href="https://docsmall.com/image-compress">在线图片压缩 - docsmall 在线图片压缩工具,在线图片压缩软件</a></p></blockquote><blockquote><p>或者直接在PicGo中直接安装compress 1.4.0插件</p></blockquote><h1 id="npm图床"><a href="#npm图床" class="headerlink" title="npm图床"></a>npm图床</h1><div class="note info flat"><p>以下会以<code>[AssetsRepo]</code>、<code>package</code>指代这个静态资源仓库、npm包名</p></div><ol><li><p>首先需要注册一个 npm 的账号。<a href="https://www.npmjs.com/signup/">访问npm 注册页面</a><br><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/01.png"></p></li><li><p>完成邮箱验证，注册完成后进入账号管理界面:头像-&gt;Account，拉倒最上方，你会看到<code>You have not verified your email address</code>字样的提示，点击以后按提示步骤验证你的邮箱。</p><p><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/02.png"></p></li><li><p>找到我们之前创建的图床仓库，在本地合适的位置把它<code>clone</code>下来。找个空文件夹打开终端输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:[username]/[AssetsRepo].git</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/[username]/[AssetsRepo].git</span><br><span class="line"></span><br><span class="line">在 <span class="built_in">clone</span> 下来的[AssetsRepo]文件夹内打开终端，输入以下指令切换回原生源</span><br></pre></td></tr></table></figure></li><li><p>在 clone 下来的[AssetsRepo]文件夹内打开终端，输入以下指令切换回原生源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure></li><li><p>添加本地 npm 用户设置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅第一次使用需要添加用户，之后会提示你输入你的npm账号密码以及注册邮箱</span></span><br><span class="line">npm adduser</span><br><span class="line"><span class="comment"># 非第一次使用直接登录即可，之后会提示你输入你的npm账号密码以及注册邮箱</span></span><br><span class="line">npm login</span><br></pre></td></tr></table></figure></li><li><p>运行 npm 初始化指令，把整个图床仓库打包，按照指示进行配置，注意需要事先确认你的包名没有和别人已发布的包重复，可以在 npm 官网搜索相应包名，搜不到就说明还没被占用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/03.png"></p><p>最后会输出一段 package.json，请求确认，输入 yes 即可。</p></li><li><p>然后输入发布指令，我们就可以把包发布到 npm 上了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></li><li><p>如果出现一下情况</p><p><code>403 403 Forbidden - PUT https://registry.npmjs.org/music - You do not have permission to publish &quot;music&quot;. Are you logged in as the correct user?</code></p><p>提示没有权限，其实就是你的<code>module</code>名在<code>npm</code>上已经被占用啦，这时候你就去需要去<code>npm</code>搜索你的模块名称，如果搜索不到，就可以用，并且把<code>package.json</code>里的<code>name</code>修改过来，重新<code>npm publish</code>。</p></li><li><p>jsdelivr+npm 的图片引用和 jsdelivr+github 很相似，例如我在<code>[AssetsRepo]</code>仓库里存放的<code>/img/index.png</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jsDelivr+github链接</span></span><br><span class="line">https://cdn.jsdelivr.net/gh/[GithubUserName]/[AssetsRepo]/img/index.png</span><br><span class="line"><span class="comment"># jsDelivr+npm链接</span></span><br><span class="line">https://cdn.jsdelivr.net/npm/[NpmPackageName]/img/index.png</span><br></pre></td></tr></table></figure><div class="note success flat"><p>可以看到 Npm 只需要提供包名即可。这也是一开始要求包名不重复的原因之一</p></div><p>jsDelivr+Npm 依然有 100MB 的包大小限制，但是 NPM 有丰富的国内节点。可以挑选一个使用。个人推荐知乎的。没有大小限制，而且也很稳定。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">【jsd出品，网宿国内节点】</span><br><span class="line">https://npm.elemecdn.com/:package@:version/:file</span><br><span class="line">【知乎出品，网宿国内节点】</span><br><span class="line">https://npm.elemecdn.com/:package@:version/:file</span><br><span class="line">【百度出品，网宿国内节点】</span><br><span class="line">https://code.bdstatic.com/npm/:package@:version/:file</span><br><span class="line">【饿了么出品，网宿国内节点】</span><br><span class="line">https://shadow.elemecdn.com/npm/:package@:version/:file</span><br></pre></td></tr></table></figure><div class="note info flat"><p>本文音乐库用的是知乎，例子<code>https://npm.elemecdn.com/music6@1.0.0/本草纲目/本草纲目.mp3</code></p></div>`<p>当然你也可以利用unpkg自建。(UNPKG 是一个内容源自 npm 的全球快速 CDN。它部署在 cloudflare 上，在大陆地区访问到的是香港节点。所以速度也不错。)</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://unpkg.com/:package@:version/:file</span><br></pre></td></tr></table></figure></li><li><p>如果每次都要在本地进行<code>npm publish</code>的话，npm 的提交是整个包一起上传的，不存在增量更新，耗时不说，而且还往往需要架梯子才能正常上传。所以我们可以把它交给 github action 来完成。</p><p>在<a href="https://www.npmjs.com/">npm 官网</a>-&gt;头像-&gt;Access Tokens-&gt;Generate New Token,勾选 Automation 选项，<code>Token</code>只会显示这一次，之后如果忘记了就只能重新生成重新配置了。</p><p><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/05.png"></p><p>在 github 的[AssetsRepo]仓库设置项里添加一个名为<code>NPM_TOKEN</code>的<code>secrets</code>，把获取的 Npm 的 Access token 输入进去。</p><p><img src="https://cdn.cbd.int/anzhiyu-static@1.0.0/img/02/06.png"></p><p>在本地的<code>[AssetsRepo]</code>文件夹下新建<code>[AssetsRepo]/.github/workflows/autopublish.yml</code>,</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Node.js</span> <span class="string">Package</span></span><br><span class="line"><span class="comment"># 监测图床分支，2020年10月后github新建仓库默认分支改为main，记得更改</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">publish-npm:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;12.x&quot;</span></span><br><span class="line">          <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">publish</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>在本地的<code>[AssetsRepo]</code>文件夹下打开终端，运行以下指令，上传新增内容至 github，即可触发部署。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将更改提交</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;npm publish&quot;</span></span><br><span class="line"><span class="comment"># 更新package版本号</span></span><br><span class="line">npm version patch</span><br><span class="line"><span class="comment"># 推送至github触发action</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>此处的四行指令顺序严格。<br>    每次更新 npm 图床都需要先修改<code>[AssetsRepo]\package.json</code>里的<code>version</code>,也就是版本号。<br>    而<code>npm version patch</code>即为更新<code> package.json</code> 里的版本号的指令，效果是末尾版本号+1，例如<code>0.0.1=&gt;0.0.2、1.1.3=&gt;1.1.4</code>。免去了打开<code>package.json</code>再修改版本号的麻烦。（大版本更新还是需要手动改的）<br>    更新 npm 图床务必要记得更新<code>package.json</code>里的版本号！</p></div></li></ol>]]></content>
      
      
      <categories>
          
          <category> 部署工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ消息与微信消息防撤回</title>
      <link href="/2023/04/17/QQ%E6%B6%88%E6%81%AF%E9%98%B2%E6%92%A4%E5%9B%9E/"/>
      <url>/2023/04/17/QQ%E6%B6%88%E6%81%AF%E9%98%B2%E6%92%A4%E5%9B%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="QQ防撤回"><a href="#QQ防撤回" class="headerlink" title="QQ防撤回"></a>QQ防撤回</h1><h2 id="前提须知"><a href="#前提须知" class="headerlink" title="前提须知"></a>前提须知</h2><ul><li>首先撤回的函数在im.dll模块中,并且用户与用户之间以及群内的撤回函数不同</li></ul><h2 id="在im-dll模块中搜索revoke，在每一个revoke上下一个断点"><a href="#在im-dll模块中搜索revoke，在每一个revoke上下一个断点" class="headerlink" title="在im.dll模块中搜索revoke，在每一个revoke上下一个断点"></a>在im.dll模块中搜索revoke，在每一个revoke上下一个断点</h2><ul><li>通过下断点来看在消息撤回前断在哪些断点上</li></ul><h2 id="发现断在这些断点上"><a href="#发现断在这些断点上" class="headerlink" title="发现断在这些断点上"></a>发现断在这些断点上</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-16%20141606_54b2d4c59bd17779246bf7cf7507ebd9.jpg" alt="&#39;https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-16%20141606_54b2d4c59bd17779246bf7cf7507ebd9.jpg&#39;"></p><h2 id="直接在函数头部返回"><a href="#直接在函数头部返回" class="headerlink" title="直接在函数头部返回"></a>直接在函数头部返回</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2_0590660d1ac0fca17da8c7eb63b768fd.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2_0590660d1ac0fca17da8c7eb63b768fd.jpg"></p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/3_d0a10b8e94ab13fc731bbf68060bca7a.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/3_d0a10b8e94ab13fc731bbf68060bca7a.jpg"></p><ul><li>发现是个人用户撤回2和群用户撤回3上可以阻止消息撤回</li></ul><h2 id="效果就不演示了，自己尝试就可以了"><a href="#效果就不演示了，自己尝试就可以了" class="headerlink" title="效果就不演示了，自己尝试就可以了"></a>效果就不演示了，自己尝试就可以了</h2><h2 id="制作特征码"><a href="#制作特征码" class="headerlink" title="制作特征码"></a>制作特征码</h2><p>ce记得搜索数组的时候将可写的选项去除</p><p>个人用户撤回2的头部是在im.dll中特征码 [55 8b ec 81 EC * * * * A1 * * * * 33 c5 89 45 fc 8b 45 0c 33 c9 53 8b 5d 08 56]的第二条</p><p>群用户撤回3的头部是在im.dll中特征码[55 8b ec 81 EC * * * * A1 * * * * 33 c5 89 45 fc 8b 45 0c 33 c9 53 8b 5d 08 56]的第三条</p><hr><h1 id="微信防撤回"><a href="#微信防撤回" class="headerlink" title="微信防撤回"></a>微信防撤回</h1><h2 id="在所有模块中查找revoke并且全部下断"><a href="#在所有模块中查找revoke并且全部下断" class="headerlink" title="在所有模块中查找revoke并且全部下断"></a>在所有模块中查找revoke并且全部下断</h2><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/1_d19ac29f36e65062ddee691e05b8a029.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main//Qexo/2023/4/1_d19ac29f36e65062ddee691e05b8a029.jpg"></p><h2 id="发现断在这些断点上-1"><a href="#发现断在这些断点上-1" class="headerlink" title="发现断在这些断点上"></a>发现断在这些断点上</h2><p>在消息撤回前会断在</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2_7da191449747b314dd522030d39bce4d.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/2_7da191449747b314dd522030d39bce4d.jpg"></p><h2 id="发现esp操作类似于内联函数，找到关键跳转"><a href="#发现esp操作类似于内联函数，找到关键跳转" class="headerlink" title="发现esp操作类似于内联函数，找到关键跳转"></a>发现esp操作类似于内联函数，找到关键跳转</h2><p>将关键跳转nop</p><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/3_bd903b5d65e7f145a1e3aadc7223084d.jpg" alt="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/3_bd903b5d65e7f145a1e3aadc7223084d.jpg"></p><h2 id="效果就不演示了，用户以及群都是走的这个函数"><a href="#效果就不演示了，用户以及群都是走的这个函数" class="headerlink" title="效果就不演示了，用户以及群都是走的这个函数"></a>效果就不演示了，用户以及群都是走的这个函数</h2><h2 id="制作特征码-1"><a href="#制作特征码-1" class="headerlink" title="制作特征码"></a>制作特征码</h2><p>关键跳转的特征码是[74 * BE * * * * E9 * * * * 83EC * 8B C4 56 57 c7]的第二条</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qq与微信逆向 </tag>
            
            <tag> qq与微信防撤回 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章发布的细节</title>
      <link href="/2023/04/14/hello-world/"/>
      <url>/2023/04/14/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Front-matter-的基本认识"><a href="#Front-matter-的基本认识" class="headerlink" title="Front-matter 的基本认识"></a>Front-matter 的基本认识</h2><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p><p>其中又分为两种</p><ul><li>Page Front-matter 用于页面配置</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">type:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标签、分类、关于、音乐馆、友情链接、相册、相册详情、朋友圈、即刻页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><ul><li>Post Front-matter 用于文章页配置</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">aside:</span><br><span class="line">swiper<span class="emphasis">_index: 1</span></span><br><span class="line"><span class="emphasis">top_</span>group<span class="emphasis">_index: 1</span></span><br><span class="line"><span class="emphasis">background: &quot;#fff&quot;</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标签</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置 top_img,文章页顶部将显示缩略图，可设为 false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章 TOC(默认为设置中 toc 的 enable 配置)</td></tr><tr><td>toc_number</td><td>【可选】显示 toc_number(默认为设置中 toc 的 number 配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中 post_copyright 的 enable 配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的<code>文章作者</code></td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的<code>文章作者</code>链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的<code>文章链接</code>链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的<code>音乐</code> 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>swiper_index</td><td>【可选】首页轮播图配置 index 索引，数字越小越靠前</td></tr><tr><td>top_group_index</td><td>【可选】首页右侧卡片组配置, 数字越小越靠前</td></tr><tr><td>background</td><td>【可选】文章背景可配置为 16 进制颜色值</td></tr></tbody></table><ol><li>首页轮播图配置: <code>swiper_index</code>, 数字越小越靠前</li><li>首页卡片配置: <code>top_group_index</code>, 数字越小越靠前</li><li>page 中 <code>background</code>, 可配置为 16 进制颜色值</li></ol><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p><code>hexo-generator-index</code> 从 2.0.0 开始，已经支持文章置顶功能。你可以直接在文章的 <code>front-matter</code> 区域里添加 <code>sticky: 1</code> 属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><h2 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h2><p>文章的 markdown 文档上,在 Front-matter 添加 cover ,并填上要显示的图片地址。</p><p>如果不配置 cover,可以设置显示默认的 cover。如果不想在首页显示 cover, 可以设置为 false。</p><p><code>文章封面的获取顺序 Front-matter 的 cover &gt; 配置文件的 default_cover &gt; false</code></p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 封面显示的位置</span></span><br><span class="line">  <span class="comment"># 三个值可配置 left , right , both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span></span><br><span class="line">  <span class="comment"># 当没有设置cover时，默认的封面显示</span></span><br><span class="line">  <span class="attr">default_cover:</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>index_enable</td><td>主页是否显示文章封面图</td></tr><tr><td>aside_enable</td><td>侧栏是否显示文章封面图</td></tr><tr><td>archives_enable</td><td>归档页面是否显示文章封面图</td></tr><tr><td>position</td><td>主页卡片文章封面的显示位置<br />-left：全部显示在左边<br />-right：全部显示在右边<br />-both：封面位置以左右左右轮流显示</td></tr><tr><td>default_cover</td><td>默认的 cover, 可配置图片链接&#x2F;顔色&#x2F;渐变色等</td></tr></tbody></table><p>当配置多张图片时,会随机选择一张作为 cover.此时写法应为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg2.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg3.png</span></span><br></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><div class="note warning flat"><p>当文章封面设置为 false 时，或者没有获取到封面配置，相关文章背景将会显示主题色。</p></div><p>相关文章推荐的原理是根据文章 <code>tags</code> 的比重来推荐</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示推荐文章数目</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># or created or updated 文章日期显示创建日或者更新日</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/JiangYinXiang3/photo@main/Qexo/2023/4/anzhiyu_048c70d031684a305bb5065f91485bc5.png" alt="&#39;&#39;"></p><h2 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h2><div class="note info flat"><p>标签外挂是 Hexo 独有的功能，并不是标准的 Markdown 格式。<br>以下的写法，只适用于 AnZhiYu 主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意</p></div><div class="note warning flat"><p>标签外挂虽然能为主题带来一些额外的功能和 UI 方面的强化，但是，标签外挂也有明显的限制，使用时请留意。</p></div><p><strong><strong>Note (Bootstrap Callout)</strong></strong></p><p><code>flat样式</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p><code>样式预览</code></p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div>]]></content>
      
      
      <categories>
          
          <category> 部署工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章发布的细节 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
